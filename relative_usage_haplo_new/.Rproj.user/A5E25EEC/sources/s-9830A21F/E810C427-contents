## dashboard

# vgerms <-
#   sapply(c("IGH", "IGK", "IGL"), function(chain)
#     tigger::readIgFasta(fasta_file = paste0("IG/", chain, "V.fasta")))
# 
# vgerms_msa <-
#   sapply(c("IGH", "IGK", "IGL"), function(chain)
#     sapply(c("TRUE","FALSE"), function(func){
#       vgerm <- vgerms[[chain]]
#       vgerm <-
#         vgerm[!grepl(paste0(c("NL", "OR"), collapse = "|"), names(vgerm))]
#       if (func) {
#         vgerm <- vgerm[functionality[[chain]]]
#         vgerm <- vgerm[!is.na(vgerm)]
#       }
#       vgerm_msa <- msa(inputSeqs = gsub("[.]","",vgerm), type = "dna", method = "Muscle")
#       return(vgerm_msa)
#     }, simplify = F), simplify = F)
# 
# 
# vgerms_full <-
#   sapply(c("IGH", "IGK", "IGL"), function(chain)
#     seqinr::read.fasta(file = paste0("IG/", chain, "V.fasta"), as.string = T))
# 
# functionality <- sapply(c("IGH","IGK","IGL"), 
#                         function(chain) 
#                           getAllele(names(vgerms_full[[chain]][!grepl("(ORF|P)", 
#                                                                       sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]))]), strip_d = F, omit_nl = F))
# 
# mat_list <- sapply(c("IGH","IGK","IGL"),function(chain){
#   sapply(c("functional","nonfunctional"), function(functional){
#     sapply(c("single","nonsingle"), function(single){
#       sapply(c("rm","all"), function(rm_short){
#         sapply(as.character(310:322), function(seq_end){    
#           vgerm <- vgerms[[chain]]
#           vgerm <-
#             vgerm[!grepl(paste0(c("NL", "OR"), collapse = "|"), names(vgerm))]
#           if (functional == "functional") {
#             vgerm <- vgerm[functionality[[chain]]]
#             vgerm <- vgerm[!is.na(vgerm)]
#           }
#           
#           if (single=="single") {
#             alleles <-
#               data.frame(
#                 alleles = names(vgerm),
#                 genes = getGene(names(vgerm), strip_d = F, omit_nl = F),
#                 stringsAsFactors = F
#               ) %>%
#               dplyr::group_by(genes) %>% dplyr::filter(row_number() == 1) %>% dplyr::pull(alleles)
#             vgerm <- vgerm[alleles]
#           }
#           
#           vgerm <- gsub("[.]", "-", vgerm)
#           tmp_first <- stringi::stri_locate(vgerm, regex = "[A-Z|a-z]")        
#           if(rm_short=="short"){
#             vgerm <- vgerm[-which(tmp_first[,1]!=1)]
#           }else{
#             for (i in 1:nrow(tmp_first)) {
#               vgerm[[i]] <-
#                 paste0(gsub("[-]", "N", substr(vgerm[[i]], 1, tmp_first[i, 1] - 1)),
#                        substr(vgerm[[i]], tmp_first[i, 1], nchar(vgerm[[i]])))
#             }  
#           }
#           
#           vgerm <-
#             sapply(vgerm, function(x)
#               ifelse(nchar(x) != max(nchar(vgerm)), paste0(x, paste0(
#                 rep("N", (max(nchar(
#                   vgerm
#                 )) - nchar(x))), collapse = ""
#               )), x))
#           
#           ## cut to 3' end value
#           vgerm <-
#             sapply(vgerm, function(x)
#               substr(x, 1, as.numeric(seq_end))
#             )
#           
#           dna <- DNAStringSet(vgerm)
#           
#           mat <-
#             DistanceMatrix(
#               dna,
#               includeTerminalGaps = FALSE,
#               penalizeGapGapMatches = FALSE,
#               penalizeGapLetterMatches = T,
#               verbose = F
#             )
#           
#           return(mat)}, simplify = F)
#       }, simplify = F)}, simplify = F)}, simplify = F)}, simplify = F)
# color = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
# col_vector <- sample(color, 200)
# 
# col_vec_dend <- strsplit("orchid3,snow4,mediumpurple1,peachpuff3,salmon,darkseagreen,skyblue2,thistle4,bisque3,deepskyblue,khaki2,papayawhip,mediumvioletred,violet,seashell4,lightblue1,darkolivegreen1,midnightblue,coral2,lightsalmon1",",")[[1]]
# 
# 
# save(mat_list, vgerms, vgerms_msa, vgerms_full, functionality, color, col_vector, col_vec_dend, file = "data.rda")


library(shiny)
library(dplyr)
library(shinyWidgets)
library(circlize)
library(Biostrings)
library(DECIPHER)
library(alakazam)
library(dendextend)
library(plotly)
library(ggplot2)
library(ggdendro)
library(htmltab)
library(bslib)
library(shinydashboard)
library(knitr)
library(dashboardthemes)
library(msa)
library(msaR)
#library(bs4Dash)
#library(BiocManager)
library(shinyBS)
library(DT)
# bioc <- local({
#   env <- new.env()
#   on.exit(rm(env))
#   evalq(source("http://bioconductor.org/biocLite.R", local = TRUE), env)
#   biocinstallRepos()
# })
options(repos = BiocManager::repositories())
#setRepositories(addURLs = c(BioC = "https://bioconductor.org/packages/3.8/bioc"))
load(file = "data.rda")
#load(file = "filtered_data.rda")
load(file = "data_frac_new.rda")
load(file = "alleles_dbs.rda")
load(file = "functional_groups.rda")

# ui ---------------------------------------------------------------------------

buildGroupInputTooltipOrPopover <- function(options, type, id, choice){
  
  options = paste0("{'", paste(names(options), options, sep = "': '", collapse = "', '"), "'}")
  
  bsTag <- shiny::tags$script(shiny::HTML(paste0("
    $(document).ready(function() {
      setTimeout(function() {
        $('input', $('#", id, "')).each(function(){
          if(this.getAttribute('value') == '", choice, "') {
            opts = $.extend(", options, ", {html: true});
            $(this.parentElement).", type, "('destroy');
            $(this.parentElement).", type, "(opts);
          }
        })
      }, 500)
    });
  ")))
  
  #print(bsTag)
  
  htmltools::attachDependencies(bsTag, shinyBS:::shinyBSDep)
}

groupInputTooltip <- function(id, choice, title, placement = "bottom", trigger = "hover", options = NULL){
  
  options = shinyBS:::buildTooltipOrPopoverOptionsList(title, placement, trigger, options)
  buildGroupInputTooltipOrPopover(options, "tooltip", id, choice)
}

groupInputPopover <- function(id, choice, title, content, placement = "bottom", trigger = "hover", options = NULL){
  
  options = shinyBS:::buildTooltipOrPopoverOptionsList(title, placement, trigger, options, content)
  buildGroupInputTooltipOrPopover(options, "popover", id, choice)
}

func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

ui <- dashboardPage(
  
  # title ----
  dashboardHeader(title = "Functional Genes Groups"),
  
  # sidebar ----
  dashboardSidebar(
    sidebarMenu(id = "sidebarid",
                tags$head(tags$script('
                                var dimension = [0, 0];
                                $(document).on("shiny:connected", function(e) {
                                    dimension[0] = window.innerWidth;
                                    dimension[1] = window.innerHeight;
                                    Shiny.onInputChange("dimension", dimension);
                                });
                                $(window).resize(function(e) {
                                    dimension[0] = window.innerWidth;
                                    dimension[1] = window.innerHeight;
                                    Shiny.onInputChange("dimension", dimension);
                                });
                            ')),
                tags$head(tags$style(HTML('
                            label {font-weight:bold;}
                            .js-irs-3 .irs-single, .js-irs-3 .irs-bar-edge, .js-irs-3 .irs-bar {
                                                  background: #F39C12;
                                                  border-top: 1px solid #F39C12 ;
                                                  border-bottom: 1px solid #F39C12 ;}

                            /* changes the colour of the number tags */
                           .js-irs-3 .irs-max { background: #ffffff; font-weight: bold; color: #F39C12 }
                           .js-irs-3 .irs-min { background: #ffffff; font-weight: bold; color: #F39C12 }
                           
                           .js-irs-0 .irs-single, .js-irs-0 .irs-bar-edge, .js-irs-0 .irs-bar {
                                                  background: #F39C12;
                                                  border-top: 1px solid #F39C12 ;
                                                  border-bottom: 1px solid #F39C12 ;}
                            /* changes the colour of the number tags */
                           .js-irs-0 .irs-max { background: #ffffff; font-weight: bold; color: #F39C12 }
                           .js-irs-0 .irs-min { background: #ffffff; font-weight: bold; color: #F39C12 }
                           
                           .js-irs-1 .irs-single, .js-irs-1 .irs-bar-edge, .js-irs-1 .irs-bar {
                                                  background: #F39C12;
                                                  border-top: 1px solid #F39C12 ;
                                                  border-bottom: 1px solid #F39C12 ;}
                            /* changes the colour of the number tags */
                           .js-irs-1 .irs-max { background: #ffffff; font-weight: bold; color: #F39C12 }
                           .js-irs-1 .irs-min { background: #ffffff; font-weight: bold; color: #F39C12 }
                           
                           .js-irs-2 .irs-single, .js-irs-2 .irs-bar-edge, .js-irs-2 .irs-bar {
                                                  background: #F39C12;
                                                  border-top: 1px solid #F39C12 ;
                                                  border-bottom: 1px solid #F39C12 ;}
                            /* changes the colour of the number tags */
                           .js-irs-2 .irs-max { background: #ffffff; font-weight: bold; color: #F39C12 }
                           .js-irs-2 .irs-min { background: #ffffff; font-weight: bold; color: #F39C12 }
                           
                           .js-irs-4 .irs-single, .js-irs-4 .irs-bar-edge, .js-irs-4 .irs-bar {
                                                  background: #F39C12;
                                                  border-top: 1px solid #F39C12 ;
                                                  border-bottom: 1px solid #F39C12 ;}
                            /* changes the colour of the number tags */
                           .js-irs-4 .irs-max { background: #ffffff; font-weight: bold; color: #F39C12 }
                           .js-irs-4 .irs-min { background: #ffffff; font-weight: bold; color: #F39C12 }
                           
                            #func_group+ div>.selectize-dropdown {border: 1px solid; border-color: steelblue; background-color: #F39C12;}'
                ))
                ),
                menuItem("Families", tabName = "page1"),
                conditionalPanel(
                  'input.sidebarid == "page1"',
                  radioGroupButtons(
                    "chain", label = HTML("<p style='color:white;'>Chain</p>") , choices = c("IGH", "IGK", "IGL"),
                    selected = "IGH", status = "info"),
                  sliderTextInput(
                    'seq_end',  HTML(paste0("<p style='color:white;'>","3' end position</p>")), choices = seq(310, 322, by = 1),
                    selected = 318, force_edges = TRUE, dragRange = FALSE, animate = FALSE),
                  materialSwitch(
                    'functional', HTML(paste0("<p style='color:white;font-weight: bold;'>","Functional alleles</p>")), status = "info", value = TRUE),
                  materialSwitch(
                    'single', HTML(paste0("<p style='color:white;font-weight: bold;'>","Single Allele</p>")), status = "info", value = FALSE),
                  materialSwitch(
                    'rm_short', HTML(paste0("<p style='color:white;font-weight: bold;'>","Remove short 5' end reads</p>")), status = "info", value = TRUE),
                  radioGroupButtons(
                    'method', HTML(paste0("<p style='color:white;'>","Clustering method</p>")), c("complete", "single", "average", "NJ"),
                    selected = "complete",  status = "info"),
                  sliderTextInput(
                    'threshold', HTML(paste0("<p style='color:white;'>","Similarity cutoff</p>")), choices = seq(50, 100, by = 1),
                    selected = 75, force_edges = TRUE, dragRange = FALSE, animate = FALSE),
                  uiOutput("sub_cluster"),
                  uiOutput("sub_cluster_hover")
                ),
                menuItem("Genes", tabName = "page2"),
                conditionalPanel(
                  'input.sidebarid == "page2"',
                  sliderTextInput(
                    'sim_cut',  HTML(paste0("<p style='color:white;'>",'Similarity cutoff value',"</p>")), choices = seq(75, 99, by = 1),
                    selected = 95, grid = TRUE, force_edges = TRUE, animate = FALSE
                  )
                ),
                menuItem("Alleles", tabName = "page_allele"),
                conditionalPanel(
                  'input.sidebarid == "page_allele"',
                  selectInput(
                      "func_group",
                      HTML("<p style='color:white;'>Functional group</p>"),
                      choices = as.character(names(func_groups)), multiple = F
                    ),
                  awesomeCheckboxGroup(
                    'project', label = HTML("<p style='color:white;'>Projects</p>"), c("P1", "P4", "P11"), 
                    selected = c("P1", "P11"), inline = TRUE, status = "info"),
                  sliderTextInput(
                    'min_seqs',  HTML(paste0("<p style='color:white;'>",'Minimum number of sequences per subject for group',"</p>")), choices = seq(1, 100, by = 1),
                    selected = 50, grid = TRUE, force_edges = TRUE, animate = FALSE
                  ),
                  sliderTextInput(
                    'allele_thresh',  HTML(paste0("<p style='color:white;'>",'Allele threshold percentage value',"</p>")), choices = seq(0, 25, by = 0.5),
                    selected = 0.5, grid = TRUE, force_edges = TRUE, animate = FALSE, post = "%"
                  ),
                  uiOutput("Zygousity", selected = "1")
                ),
                menuItem("Alignment", tabName = "page4"),
                conditionalPanel(
                  'input.sidebarid == "page4"',
                  awesomeRadio(
                    "align", label = HTML("<p style='color:white;'>Alignment</p>"), choices = c("IMGT", "MSA"),
                    selected = "IMGT", inline = FALSE, status = "danger"),
                  awesomeRadio(
                    "chain_seq", label = HTML("<p style='color:white;'>Chain</p>"), choices = c("IGH", "IGK", "IGL"),
                    selected = "IGH", inline = FALSE, status = "danger"),
                  materialSwitch(
                    'functional_seq',  HTML("<p style='color:white;'>Functional alleles</p>"), status = "success", value = TRUE)
                )
    )
  ),
  
  # body ----
  dashboardBody(
     shinyDashboardThemes(
       theme = "blue_gradient"
     ),
     tags$head(tags$style(HTML('

                              .btn-danger {
                                    color: #fff;
                                    background-color: #d9534f;
                                    border-color: #d43f3a;
                              }
                                
                              .radioGroupButtons .btn:hover {
                              color: #fff;
                              background-color: #FF7F7F;
                              }
                              
                              .popover-title{
                              color: #ffffff;
                              font-size: 16px;
                              background-color: #7F7F7F;
                              }

                              .popover-header{ 
                              background: #666666; 
                              } 

                              .popover-content{ 
                              color: #000000;
                              background: #ffffff; 
                              }

                              .tooltip .tooltiptext {
                              visibility: hidden;
                              width: 120px;
                              background-color: black;
                              color: #666666;
                              text-align: center;
                              border-radius: 6px;
                              padding: 5px 0;
                              position: absolute;
                              z-index: 1;
                              bottom: 100%;
                              left: 50%;
                              margin-left: -60px;
                              }

                              .tooltip:hover .tooltiptext {
                              visibility: visible;
                              opacity: 1;
                              }
    '))),
    tabItems(
      # page 2 ----
      tabItem(tabName = "page1", "Sub-groups of the alleles of the chosen chain based on similarity cut-off and IMGT alignment.",
              br(), br(),
              #plotOutput("plot"),
              div(style='max-width:2500px; overflow-x: scroll; position: relative',plotOutput("plot", width = "2500px")),
              downloadButton(outputId = "down", label = "Download The Plot"), 
              br(),
              #verbatimTextOutput("info"),
              h5("Choose any of the sub groups in the left sidebar to display the plot. Slide the red line in the plot below to control the cut-off"),
              plotlyOutput("sub_plot"),
              br(),
              DT::DTOutput("table")),
      # page 2 ----
      tabItem(tabName = "page2", 
              "The top plot is the clustering of the functional groups based on similiarity cut-off.\nThe bottom plot is the jaccard distance similarity of the new groups to the IMGT gene",
              br(), br(),
              div(style='max-width:2500px; overflow-x: scroll; position: relative',plotlyOutput("plot2", width = "3000px")),#plotlyOutput("plot2"),
              br(),br(),
              h5("The Jaccard distance index, showing the similarity between the genes cluster by IMGT and the new functional groups"),
              plotlyOutput("plot3"),
              br(),
              DT::DTOutput("table2")),
      # page 3 ----
      tabItem(tabName = "page_allele", 
              "The allele relative frequency in the repertoire based on the functional groups. Group similarity of 95% based on complete linkage and functional sequences and up to position 318",
              br(), 
              DT::DTOutput("table4"),
              br(),
              dropdown(
                awesomeRadio(
                  'leg',
                  'Legend order',
                  c("Alphabetical", "Frequency"),
                  selected = "Alphabetical",
                  inline = TRUE,
                  status = "info"
                ),
                style = "unite",
                icon = icon("gear"),
                status = "danger",
                width = "300px",
              ),
              plotlyOutput("plot4"),
              br(),
              dropdown(
                materialSwitch(
                  inputId = "decimal",
                  label = "Round assignments counts",
                  value = TRUE,
                  status = "info"
                ),
                switchInput(
                  inputId = "btn_collapse",
                  label = "Subject grouping",
                  onStatus = "success",
                  offStatus = "danger",
                  value = TRUE
                ),
                style = "unite",
                icon = icon("gear"),
                status = "danger",
                width = "300px",
              ),
              DT::DTOutput("table3")),
      # page 4 ----
      tabItem(tabName = "page4", "Sequence alignment options: Choose one of IMGT numbering, Multiple sequence alignments (MUSCLE).",
              br(), br(),
              msaROutput("msa", width="100%"))
    )
  )
)

# server -----------------------------------------------------------------------


func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`


hline <- function(y = 0, color = "red") {
  list(
    type = "line",
    x0 = 0,
    x1 = 1,
    xref = "paper",
    y0 = y,
    y1 = y,
    line = list(color = color, dash = "dot")
  )
}

callback_js <- JS(
  "table.on('click', 'tr.dtrg-group', function () {",
  "  var rowsCollapse = $(this).nextUntil('.dtrg-group');",
  "  $(rowsCollapse).toggleClass('hidden');",
  "});"
)

jacc <- function(a, b){
  jacc <- length(intersect(a, b))/length(unique(c(a, b)))
  #return(1 - jacc)
}

rect.dendrogram2 <- function (tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, 
                              cluster = NULL, horiz = FALSE, density = NULL, angle = 45, 
                              text = NULL, text_cex = 1, text_col = 1, xpd = TRUE, lower_rect, 
                              upper_rect = 0, prop_k_height = 0.5, stop_if_out = FALSE, 
                              ...) 
{
  if (!is.dendrogram(tree)) 
    stop("x is not a dendrogram object.")
  if (length(h) > 1L | length(k) > 1L) {
    stop("'k' and 'h' must be a scalar(i.e.: of length 1)")
  }
  tree_heights <- heights_per_k.dendrogram(tree)[-1]
  tree_order <- order.dendrogram(tree)
  if (!is.null(h)) {
    if (!is.null(k)) {
      stop("specify exactly one of 'k' and 'h'")
    }
    ss_ks <- tree_heights < h
    k <- min(as.numeric(names(ss_ks))[ss_ks])
    k <- max(k, 2)
  }
  else if (is.null(k)) {
    stop("specify exactly one of 'k' and 'h'")
  }
  if (k < 2 | k > length(tree_heights)) {
    if (stop_if_out) {
      stop(gettextf("k must be between 2 and %d", length(tree_heights)), 
           domain = NA)
    }
    else {
      warning(gettextf("k must be between 2 and %d", length(tree_heights)), 
              domain = NA)
    }
  }
  if (is.null(cluster)) {
    cluster <- cutree(tree, k = k)
  }
  clustab <- table(cluster)[unique(cluster[tree_order])]
  m <- c(0, cumsum(clustab))
  if (!is.null(x)) {
    if (!is.null(which)) {
      stop("specify exactly one of 'which' and 'x'")
    }
    which <- x
    for (n in seq_along(x)) which[n] <- max(which(m < x[n]))
  }
  else if (is.null(which)) {
    which <- 1L:k
  }
  if (any(which > k)) {
    stop(gettextf("all elements of 'which' must be between 1 and %d", 
                  k), domain = NA)
  }
  border <- rep_len(border, length(which))
  retval <- list()
  old_xpd <- par()["xpd"]
  par(xpd = xpd)
  for (n in seq_along(which)) {
    next_k_height <- tree_heights[names(tree_heights) == 
                                    k + 1]
    if (length(next_k_height) == 0) {
      next_k_height <- 0
      prop_k_height <- 1
    }
    if (!horiz) {
      xleft <- m[which[n]] + 0.66
      if (missing(lower_rect)) {
        lower_rect <- -max(strheight2(labels(tree)))
        dLeaf <- -0.75 * strheight("x")
        extra_space <- -strheight2("_")
        lower_rect <- lower_rect + dLeaf + extra_space
      }
      ybottom <- lower_rect
      xright <- m[which[n] + 1] + 0.33
      ytop <- tree_heights[names(tree_heights) == k] * 
        prop_k_height + next_k_height * (1 - prop_k_height) + 
        upper_rect
    }
    else {
      ybottom <- m[which[n]] + 0.66
      if (missing(lower_rect)) {
        lower_rect <- min(strwidth(labels(tree)))
        dLeaf <- 0.75 * strwidth("w")
        extra_space <- strwidth("_")
        lower_rect <- lower_rect + dLeaf + extra_space
      }
      xright <- lower_rect
      ytop <- m[which[n] + 1] + 0.33
      xleft <- tree_heights[names(tree_heights) == k] * 
        prop_k_height + next_k_height * (1 - prop_k_height) + 
        upper_rect
    }
    rect(xleft, ybottom, xright, ytop, border = border[n], 
         density = density, angle = angle, ...)
    if (!is.null(text)) {
      text((m[which[n]] + m[which[n] + 1] + 1)/2, ytop+0.01, text[n], 
           cex = text_cex, col = text_col)
    }
    retval[[n]] <- which(cluster == as.integer(names(clustab)[which[n]]))
  }
  par(xpd = old_xpd)
  invisible(retval)
}

server <- function(input, output, session) {
  
  func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`
  observe({
    query <- parseQueryString(session$clientData$url_search)
    
    if(!is.null(query$url)) {
      url <- strsplit(query$url,"\"")[[1]][2]
      allele_thresh <- as.numeric(strsplit(query$allele_thresh, "\"")[[1]][2])
      func_group <- strsplit(query$func_group, "\"")[[1]][2]
      print(allele_thresh)
      updateTabsetPanel(session, 'sidebarid', url)
      updateSliderTextInput(session, 'allele_thresh',selected = allele_thresh)
      updateSelectInput(session, 'func_group',selected = func_group)
    }
  })

  # alignment graph --------------------------------------------------------------------
  
  output$msa = renderMsaR({
    req(input$dimension)
    if(input$align == "IMGT"){
      vgerm <- vgerms[[input$chain_seq]]
      vgerm <-
        vgerm[!grepl(paste0(c("NL", "OR"), collapse = "|"), names(vgerm))]
      if (input$functional_seq) {
        vgerm <- vgerm[functionality[[input$chain_seq]]]
        vgerm <- vgerm[!is.na(vgerm)]
      }
      
      vgerm <-
        sapply(vgerm, function(x)
          ifelse(nchar(x) != max(nchar(vgerm)), paste0(x, paste0(
            rep("-", (max(nchar(
              vgerm
            )) - nchar(x))), collapse = ""
          )), x))
      
      dna <- DNAStringSet(gsub("[.]","-",vgerm))
      
    }else{
      if(input$align == "MSA"){
        
        vgerm <- vgerms_msa[[input$chain_seq]][[ifelse(input$functional_seq,1,2)]]
        dna <- vgerm@unmasked
      }
    }
    
    msaR::msaR(msa = dna, overviewbox = FALSE, alignmentHeight = input$dimension[2]*0.5)
  })
  
  
  
  
  # main matrix --------------------------------------------------------------------
  
  mat = reactive({
    # vgerm <- vgerms[[input$chain]]
    # vgerm <-
    #   vgerm[!grepl(paste0(c("NL", "OR"), collapse = "|"), names(vgerm))]
    # if (input$functional) {
    #   vgerm <- vgerm[functionality[[input$chain]]]
    #   vgerm <- vgerm[!is.na(vgerm)]
    # }
    # 
    # if (input$single) {
    #   alleles <-
    #     data.frame(
    #       alleles = names(vgerm),
    #       genes = getGene(names(vgerm), strip_d = F, omit_nl = F),
    #       stringsAsFactors = F
    #     ) %>%
    #     dplyr::group_by(genes) %>% dplyr::filter(row_number() == 1) %>% dplyr::pull(alleles)
    #   vgerm <- vgerm[alleles]
    # }
    # 
    # vgerm <- gsub("[.]", "-", vgerm)
    # tmp_first <- stringi::stri_locate(vgerm, regex = "[A-Z|a-z]")
    # for (i in 1:nrow(tmp_first)) {
    #   vgerm[[i]] <-
    #     paste0(gsub("[-]", "N", substr(vgerm[[i]], 1, tmp_first[i, 1] - 1)),
    #            substr(vgerm[[i]], tmp_first[i, 1], nchar(vgerm[[i]])))
    # }
    # 
    # vgerm <-
    #   sapply(vgerm, function(x)
    #     ifelse(nchar(x) != max(nchar(vgerm)), paste0(x, paste0(
    #       rep("N", (max(nchar(
    #         vgerm
    #       )) - nchar(x))), collapse = ""
    #     )), x))
    # 
    # ## cut to 3' end value
    # vgerm <-
    #   sapply(vgerm, function(x)
    #     substr(x, 1, input$seq_end)
    #   )
    # 
    # dna <- DNAStringSet(vgerm)
    # 
    # mat <-
    #   DistanceMatrix(
    #     dna,
    #     includeTerminalGaps = FALSE,
    #     penalizeGapGapMatches = FALSE,
    #     penalizeGapLetterMatches = T,
    #     verbose = F
    #   )
    
    mat <- mat_list[[input$chain]][[ifelse(input$functional,"functional","nonfunctional")]][[ifelse(input$single,"single","nonsingle")]][[ifelse(input$rm_short,"rm","all")]][[as.character(input$seq_end)]]
    
    
    return(mat)
    
  })
  
  # cut by similarity --------------------------------------------------------------------
  
  clust = reactive({
    if(input$method == "NJ"){
    clust <-
      IdClusters(
        myDistMatrix = mat(),
        collapse = -1,
        method = ifelse(input$method == "average", "UPGMA", input$method),
        cutoff = (1 - input$threshold / 100),
        showPlot = F,
        verbose = F,
        type = "both"
      )
    }else{
      clust <- hclust(as.dist(mat()), input$method)
      cut <- data.frame(cluster = cutree(clust, h = (1 - input$threshold / 100)))
      clust <- list(cut, as.dendrogram(clust))
    }
    return(clust)
    
  })
  
  # plot the dendrogram --------------------------------------------------------------------
  
  cluster_main <- reactive({
    clusters <- clust()[[1]]$cluster
    names(clusters) <- rownames(clust()[[1]])
    return(clusters)
  })
  
  dend_main <- reactive({
    dend <- clust()[[2]]
    return(dend)
  })
  
  dendo_plot = reactive({
    clusters <- cluster_main()
    dend <- dend_main()
    fam_clusters <- clusters
    
    clusters <- clusters[order.dendrogram(dend)]
    clusters_numbers <- unique(clusters) - (0 %in% clusters)
    n_clusters <- length(clusters_numbers)
    
    mypal = setNames(alpha(col_vec_dend[1:n_clusters],0.99), 1:n_clusters) 
    cluster_new <- mypal[clusters]
    
    clusters_imgt <- clusters
    clusters_imgt <- getFamily(names(clusters_imgt), strip_d = F, omit_nl = F)
    
    imgt_colors <-
      setNames(colorspace::diverging_hcl(length(unique(clusters_imgt)), alpha = 0.99, palette = "Tropic"), sort(unique(clusters_imgt)))
    clusters_imgt <-   imgt_colors[clusters_imgt]
    
    dend2 <-
      dend %>% branches_attr_by_clusters(clusters, values = mypal) %>% dendextend::set("labels_cex", 0.9)
    
    if (input$method != "NJ") {
      par(mar = c(12, 4, 1, 1))
      dend2 %>% plot
      dend2 %>% rect.dendrogram2(
        k = n_clusters,lower_rect = 0,
        text = clusters_numbers, xpd = T,
        #border = 8,
        lty = 5,
        lwd = 2,
        border = mypal
      )
      colored_bars(
        cbind(clusters_imgt, cluster_new),
        dend2,
        sort_by_labels_order = F,
        rowLabels = c("IMGT", "NEW")
      )
    } else{
      par(mar = c(12, 4, 1, 1))
      dend2 %>% plot
      colored_bars(
        cbind(clusters_imgt, mypal[clusters]),
        dend2,
        sort_by_labels_order = F,
        rowLabels = c("IMGT", "NEW")
      )
    }
  })
  
  output$plot = renderPlot({
    dendo_plot()
  })
  
  download_input <- reactive({
    "pdf"
  })
  
  #output$info <- renderPrint(reactiveValuesToList(session$clientData))
  
  ## call the plot function when downloading the image
  output$down <- downloadHandler(
    filename =  function() {
      paste(paste(input$chain,input$method,input$threshold, sep = "_"),download_input(),sep= ".")
    },
    # content is a function with argument file. content writes the plot to the device
    content = function(file) {
      pdf(file, width = unit(session$clientData[["output_plot_width"]]*0.05, units = "inches"), height = unit(session$clientData[["output_plot_height"]]*0.02,"inches")) # open the pdf device
      par(mar = c(12, 4, 1, 1))
      
      clusters <- cluster_main()
      dend <- dend_main()
      fam_clusters <- clusters
      
      clusters <- clusters[order.dendrogram(dend)]
      clusters_numbers <- unique(clusters) - (0 %in% clusters)
      n_clusters <- length(clusters_numbers)
      
      mypal = setNames(alpha(col_vec_dend[1:n_clusters],0.99), 1:n_clusters) 
      cluster_new <- mypal[clusters]
      
      clusters_imgt <- clusters
      clusters_imgt <- getFamily(names(clusters_imgt), strip_d = F, omit_nl = F)
      
      imgt_colors <-
        setNames(colorspace::diverging_hcl(length(unique(clusters_imgt)), alpha = 0.99, palette = "Tropic"), sort(unique(clusters_imgt)))
      clusters_imgt <-   imgt_colors[clusters_imgt]
      
      dend2 <-
        dend %>% set("branches_lwd",3) %>% branches_attr_by_clusters(clusters, values = mypal) %>% dendextend::set("labels_cex", 1)
      
      if (input$method != "NJ") {
        dend2 %>% plot
        dend2 %>% rect.dendrogram2(
          k = n_clusters,lower_rect = 0,
          text = 1:n_clusters, xpd = T,text_cex = 1,
          #border = 8,
          lty = 5,
          lwd = 4,
          border = mypal
        )
        colored_bars(
          cbind(clusters_imgt, cluster_new),
          dend2,
          sort_by_labels_order = F,
          rowLabels = c("IMGT", "NEW"), cex.rowLabels = 1, y_shift = 0.5, add = T
        )
        axis(2, cex = 10)
      } else{
        dend2 %>% plot
        colored_bars(
          cbind(clusters_imgt, mypal[clusters]),
          dend2,
          sort_by_labels_order = F,
          rowLabels = c("IMGT", "NEW"), cex.rowLabels = 10, y_shift = 0.5, add = T
        )
      } 
      dev.off()  # turn the device off
    } 
  )
  
  
  # plot sub dendrogram --------------------------------------------------------------------
  
  n_labels_clusters <- reactive({
    
    clusters <- cluster_main()[order.dendrogram(dend_main())]
    n_clusters <- table(clusters)
    n_clusters <- names(n_clusters)[n_clusters>1]
    return(list(labels_clusters = clusters, n_clusters = n_clusters))
  })
  
  output$sub_cluster <- renderUI({
    radioGroupButtons(
      "sub_group",
      HTML(paste0("<p style='color:white;'>","Sub group to plot: ","</p>")),
      choices = as.character(n_labels_clusters()$n_clusters), 
      status = "info"
    )
  })
  
  output$sub_cluster_hover <- renderUI({
    tags$span(
    lapply(n_labels_clusters()$n_clusters, function(cl){
      labels <- names(n_labels_clusters()$labels_clusters)[n_labels_clusters()$labels_clusters==as.numeric(cl)]
      labels <- paste0(unique(getGene(labels, strip_d = F, omit_nl = F, collapse = T)), collapse = "&#10;&#13")
      
      groupInputPopover(
      id = "sub_group",
      choice = as.character(cl), 
      title = paste0("Group ", cl," :") , 
      content = labels
      )
      }
    ))
  })
  
  rv <- reactiveValues(g = NULL, h = 0.1)
  
  observe({
    req(input$sub_group)
    clusters <- cluster_main()
    dend <- dend_main()
    clusters <- clusters[order.dendrogram(dend)]
    
    labs <- names(clusters)[clusters==as.numeric(input$sub_group)]
    
    if(is.null(rv$g)){
      rv$g <- labs
    }else{
      
      if(any(!labs %in% rv$g)){
        rv$h <- 0.1
        rv$g <- labs
      }else{
        rv$g <- labs
      }
    }
  })
  
  sub_mat <- reactive({
    if (is.null(rv$g))
      return(NULL)
    
    
    return(mat()[rv$g, rv$g])
    
  })
  
  output$sub_plot <- renderPlotly({
    req(input$sub_group)

    if(input$method == "NJ"){
      hc <-
        IdClusters(
          myDistMatrix = sub_mat(),
          collapse = -1,
          method = ifelse(input$method == "average", "UPGMA", input$method),
          cutoff = rv$h,
          showPlot = F,
          verbose = F,
          type = "both"
        )
    }else{
      hc <- hclust(as.dist(sub_mat()), input$method)
      cut <- data.frame(cluster = cutree(hc, h = rv$h))
      hc <- list(cut, as.dendrogram(hc, hang = -1))
    }
    
    sub_clust <- hc[[1]]
    #hc_dend <- hc[[2]]
    hc_dend <- hc[[2]]
    
    dendr    <-
      dendro_data(hc_dend, type = "rectangle") # convert for ggplot
    clust.df <-
      data.frame(label = rownames(sub_clust),
                 cluster = factor(sub_clust$cluster))
    dendr[["labels"]]   <-
      merge(dendr[["labels"]], clust.df, by = "label")
    
    rect <- aggregate(x ~ cluster, label(dendr), base::range)
    rect <- data.frame(rect$cluster, rect$x)
    
    k <- length(unique(sub_clust$cluster))
    ymax <- mean(as.hclust(hc_dend)$height[length(as.hclust(hc_dend)$height)-((k-2):(k-1))])
    
    mypal = colorspace::rainbow_hcl(length(levels(label(dendr)$cluster)), alpha = 1)

    labels(hc_dend) <- rep("",length(labels(hc_dend)))
    dend_plot <- hc_dend %>%
      #branches_attr_by_clusters(clusters = sub_clust$cluster, values = mypal[sub_clust$cluster]) %>%
      dendextend::branches_color(h = rv$h, col = mypal) %>% 
      dendextend::set("branches_lwd", 0.7) %>%
      dendextend::set("leaves_pch", 19) %>% dendextend::set("leaves_cex", 0.5)
    
    
    ggd1 <- ggplot(as.ggdend(dend_plot)) +
      ggplot2::theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.title.x = element_text(colour = NA),
        axis.title.y = element_blank(),
        axis.text.x = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank()
      ) +
      scale_x_continuous(breaks = label(dendr)$x,
                         labels = label(dendr)$label, expand = c(0, 0.01)) +
      theme(axis.text.x = element_text(
        angle = 90,
        vjust = 0.5,
        hjust = 1,
        colour = mypal[label(dendr)$cluster]
      )) + scale_y_continuous(expand = c(0.01,0))  +
      theme(axis.text.y = element_text(), axis.ticks.y = element_line()) +
      geom_segment(aes_all(c('x', 'y', 'xend', 'yend')),
                   data = data.frame(x = c(0), xend = c(0), y = c(0.00),
                                     yend = c(max((rv$h), round(max(get_branches_heights(dend_plot)), 2)))))#/2
    
    pp <- ggplotly(ggd1, source="subdendo") %>% layout(showlegend = FALSE)
    
  
    pp$x$layout$shapes <- list(
      if (is.null(pp$x$layout$shapes))
        list()
      else
        pp$x$layout$shapes,
      list(
        type = "line",
        line = list(color = "red", dash = "dot"),
        x0 = 0,
        x1 = 1,
        y0 = (rv$h), #/2
        y1 = (rv$h), #/2
        xref = "paper"
      )
    )
    
    
    pp <-
      pp %>% config(edits = list(shapePosition = TRUE),
                    scrollZoom = FALSE)
    
    
    
  })

  #.update x/y reactive values in response to changes in shape anchors
  observe({
    ed <- event_data("plotly_relayout", source="subdendo")
    if (length(ed) < 1)
      return()
    pts <- as.numeric(ed[length(ed)])#*2
    pts <- round(pts,6)
    pts <- ifelse(pts<0.0001, 0.1, ifelse(pts>1,0.1,pts))
    rv$h <- pts

  })

  # sub group table --------------------------------------------------------------------
  
  output$table <- DT::renderDataTable(
    {
      req(input$sub_group)

      if(input$method == "NJ"){
        hc <-
          IdClusters(
            myDistMatrix = sub_mat(),
            collapse = -1,
            method = ifelse(input$method == "average", "UPGMA", input$method),
            cutoff = rv$h,
            showPlot = F,
            verbose = F,
            type = "both"
          )
      }else{
        hc <- hclust(as.dist(sub_mat()), input$method)
        cut <- data.frame(cluster = cutree(hc, h = rv$h))
        hc <- list(cut, as.dendrogram(hc, hang = -1))
      }
      
      sub_clust <- hc[[1]]
      
      colnames(sub_clust) <- "groups"
      
      sub_clust$alleles <- rownames(sub_clust)
      
      tab <- DT::datatable(
        sub_clust %>% group_by(groups) %>% summarise(genes = paste0(unique(getGene(alleles, strip_d = F, omit_nl = F)), collapse = ","), 
                                                     alleles = paste0(alleles, collapse = ","))
      )
      tab
    })
  
  
  # gene plot --------------------------------------------------------------------
  
  hc_plot = reactive({

    
    range_seq <- 1-as.numeric(input$sim_cut)/100
    
    if(input$method == "NJ"){
      row_order <- labels(IdClusters(myDistMatrix = mat(), 
                                     collapse = -1, 
                                     method = ifelse(input$method == "average", "UPGMA", input$method), 
                                     cutoff = 0.25, 
                                     verbose = F, 
                                     showPlot = F, 
                                     type = "dendrogram"))
      
      
      hc_sub <- IdClusters(myDistMatrix = mat(), collapse = -1, 
                           method = ifelse(input$method == "average", "UPGMA", input$method), 
                           cutoff = range_seq, verbose = F)
      
    }else{
      hc_sub <- hclust(as.dist(mat()), input$method)
      row_order <- labels(as.dendrogram(hc_sub, hang = -1))
      cut <- data.frame(cluster = cutree(hc_sub, h = range_seq))
      hc_sub <- cut
    }

    
    colnames(hc_sub) <- paste0((1-range_seq)*100, "%")
    
    imgt <- unique(getGene(rownames(hc_sub), strip_d = F, omit_nl = F))
    imgt <- setNames(1:length(imgt), imgt)
    hc_sub$IMGT <- imgt[getGene(rownames(hc_sub), strip_d = F, omit_nl = F)]
    
    hc_sub$labels <- factor(rownames(hc_sub), levels = row_order)
    hc_sub$labels_ind <- setNames(1:length(levels(hc_sub$labels)), levels(hc_sub$labels))[hc_sub$labels]
    hc_plot <- reshape2::melt(hc_sub, id.vars = c("labels", "labels_ind"))
    
    hc_plot$freq <- 1
    
    hc_plot$variable <- factor(hc_plot$variable, levels = c("IMGT", paste0((1-range_seq)*100, "%")))
    
    return(hc_plot)
  })
  
  output$plot2 = renderPlotly({
    
    p <- ggplot(hc_plot(), aes(x = labels_ind, y = variable, fill = factor(value), text = labels)) +
      geom_tile(color = "white") + 
      scale_fill_manual(values = col_vector) + 
      theme_minimal(base_size = 12) + 
      theme(legend.position = "none", 
            axis.title.x = element_blank(), 
            axis.title.y = element_blank(),
            #axis.ticks.y = element_blank(), 
            #axis.text.y = element_blank(),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.spacing.y = unit(1e-5, "lines"), 
            axis.text.x = element_text(angle = 90, vjust = 0.5)) + 
      scale_x_continuous(breaks = 1:length(levels(hc_plot()$labels)),
                         labels = levels(hc_plot()$labels),
                         sec.axis = dup_axis())
    ggplotly(p, tooltip = "text")  %>% layout(showlegend = FALSE)     
  })
  
  jaccard_data = reactive({
    
    if(input$method == "NJ"){
      row_order <- labels(IdClusters(myDistMatrix = mat(), 
                                     collapse = -1, 
                                     method = ifelse(input$method == "average", "UPGMA", input$method), 
                                     cutoff = 0.25, 
                                     verbose = F, 
                                     showPlot = F, 
                                     type = "dendrogram"))

    }else{
      row_order <- labels(as.dendrogram(hclust(as.dist(mat()), input$method), hang = -1))
    }
    
    imgt <- unique(getGene(row_order, strip_d = F, omit_nl = F))
    imgt <- setNames(1:length(imgt), imgt)
    IMGT <- imgt[getGene(row_order, strip_d = F, omit_nl = F)]
    names(IMGT) <- row_order
    
    tmp <- hc_plot() %>% filter(variable != "IMGT") 
    jaccard_data <- do.call(rbind, lapply(names(imgt), function(g){
      imgt_alleles <- names(IMGT)[IMGT==imgt[g]]
      tmp %>% group_by(value) %>% 
        dplyr::summarise(jacc_sim = jacc(as.character(labels), 
                                         as.character(imgt_alleles)), 
                         imgt_gene = g, labels = paste0(labels, collapse = ",")) %>% filter(jacc_sim != 0) %>% group_by(imgt_gene) %>% 
        dplyr::summarise(jacc_sim = max(jacc_sim, na.rm = T), 
                         value = paste0("Cluster: ", value, ", Jaccard value:", 
                                        round(jacc_sim, 2)*100, collapse = "\n"),
                         jacc_sim_per = round(jacc_sim,2)*100)
    }))
    
    jaccard_data$imgt_gene <- factor(jaccard_data$imgt_gene , levels = names(imgt))
    jaccard_data$imgt_gene_ind <- imgt[jaccard_data$imgt_gene]
    jaccard_data$fill <- cut(jaccard_data$jacc_sim_per, breaks=c(0, 10, 40, 70, 80, 90, 95, 100))
    jaccard_data$lower <- jaccard_data$jacc_sim_per < 100
    
    return(jaccard_data)
    
  })
  
  # similarity plot --------------------------------------------------------------------
  
  
  output$plot3 = renderPlotly({
    
    
    mypal = setNames(ggsci::pal_npg(palette = "nrc", alpha = 0.7)(length(levels(jaccard_data()$fill))),rev(levels(jaccard_data()$fill)))
    
    p2 <- ggplot(jaccard_data(), aes(imgt_gene_ind, jacc_sim_per, text = value, fill = fill)) +
      geom_col() + scale_fill_manual(values = mypal) +
      theme_classic(base_size = 14) + scale_y_continuous(expand = c(0, 0)) + scale_x_discrete(expand = c(0, 0)) +
      theme(axis.text.x = element_text(angle = 90), legend.position = "bottom") + labs(y = "Jaccard similarity", x = "", fill = "")
    
    
    p3 <- ggplotly(p2, tooltip = "text")
    
    p4 <- p3 %>% add_trace(xaxis='x2', inherit = T)
    
    labels <- levels(jaccard_data()$imgt_gene)
    n_labels <- length(levels(jaccard_data()$imgt_gene))
    ticks <- jaccard_data()$imgt_gene_ind
    tick_high <- ticks[!jaccard_data()$lower]
    tick_low <- ticks[jaccard_data()$lower]
    
    #print((tick_high))
    #print((tick_low))
    
    font_size <- p4$x$layout$xaxis$tickfont$size
    range <- p4$x$layout$xaxis$range
    ticklen <- p4$x$layout$xaxis$ticklen
    tickwidth <- p4$x$layout$xaxis$tickwidth
    
    p5 <- p4  %>% layout(xaxis=list(range=range,
                                    tickvals=tick_high,
                                    ticktext = names(tick_high),
                                    tickfont=list(color='black')),
                         xaxis2=list(range=range, 
                                     overlaying='x',
                                     ticktext = names(tick_low),
                                     tickvals = tick_low,
                                     tickangle=270, 
                                     tickfont=list(color='rgba(222,45,38,0.8)', size = font_size), 
                                     tickcolor = "rgba(51,51,51,1)", showticklabels = TRUE, 
                                     ticklen = ticklen, tickwidth = tickwidth
                         ))
    
    p5
    
  })
  
  # clusters table --------------------------------------------------------------------
  
  output$table2 <- DT::renderDataTable(
    {
      tab <- DT::datatable(
        hc_plot() %>% filter(variable != "IMGT")  %>%  dplyr::group_by(value) %>% dplyr::summarise(genes = paste0(unique(getGene(labels, strip_d = F, omit_nl = F)), collapse = ","))
      )
      tab
    })
  
  # allele relative frequency --------------------------------------------------------------------
 
  
  data_frac_plot = reactive({
    req(input$func_group)
    
    alleles_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
    tmp_allele_db <-
      alleles_db %>% filter(grepl(func_groups[as.character(input$func_group)], new_allele)) %>%
      dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))
    or_allele <-
      setNames(gsub(input$chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
        paste0(func_groups[as.character(input$func_group)], "[*]"),
        "",
        tmp_allele_db$new_allele
      )))
    
    tmp <- data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`
    tmp <- tmp %>% filter(project %in% input$project) %>%
      dplyr::filter(v_gene == func_groups[as.character(input$func_group)], !is.na(v_allele)) %>% 
      dplyr::ungroup()
    tmp <- tmp %>% dplyr::group_by(subject) %>% dplyr::filter(sum(count)>=input$min_seqs)
    if (nrow(tmp) != 0) {
      tmp <- tmp %>% dplyr::arrange(desc(freq)) %>%
        dplyr::group_by(subject, v_gene) %>% dplyr::mutate(
          zygousity_state = as.numeric(sum(freq > input$allele_thresh/100, na.rm = T)),
          v_alleles = paste0(1:unique(zygousity_state), " - ", or_allele[v_allele[1:unique(zygousity_state)]], collapse = ";"),
          v_alleles_abc = paste0(sort(or_allele[v_allele[1:unique(zygousity_state)]]), collapse = ";"),
          v_allele_axis = or_allele[v_allele]
        ) %>% dplyr::arrange(subject)
      tmp <- tmp %>% dplyr::group_by(subject, zygousity_state) %>% dplyr::mutate(loc_state = loc <= zygousity_state) %>% dplyr::filter(loc_state) %>% dplyr::ungroup()
      output$Zygousity <- renderUI({
        radioGroupButtons(
          "zygousity",
          HTML("<p style='color:white;'>Number of alleles present: </p>"),
          choices = as.character(unique(
            tmp %>% arrange(zygousity_state) %>% pull(zygousity_state)
          )),
          status = "info"
        )
      })

      tmp

    } else{
      tmp
    }
  })
  
  plotData = reactive({
    shiny::validate(need(
      nrow(data_frac_plot()) > 0,
      "No functional rearrangements were found for this selection. Try changing the number of sequences or the threshold"
    ))
    
    dplyr::filter(data_frac_plot(),
           zygousity_state == ifelse(length(input$zygousity) == 0, "1", input$zygousity))
  })
  
  theme_plot <-
    theme(
      axis.text = element_text(size = 14),
      legend.spacing = unit(1, "cm"),
      legend.position = "bottom"
    )
  
  
  output$table4 <- DT::renderDataTable(
    {
      tab <- DT::datatable(
        read.delim("Potential_thresholds_IGH.tsv", stringsAsFactors = F),
        selection = 'none',
        filter = list(
          position = "top",
          clear = TRUE,
          plain = FALSE
        ),options = list(dom = "tipr", lengthMenu = list(c(3,5), c("3","5"))),
        
        colnames = c(
          "Functional group" = "Functional.Group",
          "Minimum sequences per group" = "min_seqs",
          "Allele threshold percentage value" = "Cutoff.State"
        ))
    })
  
  output$plot4 = renderPlotly({
    tmp_plot <- plotData() %>% dplyr::rowwise() %>% dplyr::mutate(
      v_alleles_p = ifelse(input$leg == "Frequency",
                           v_alleles,
                           v_alleles_abc),
      v_alleles_p = gsub(";", "\n", v_alleles_p),
      text = paste(
        '</br>Project: ',
        project,
        '</br>Subject: ',
        subject,
        '</br>Alleles: ',
        v_alleles,
        '</br># assignments: ',
        count,
        '</br>Relative freq.: ',
        round(freq, 4),
        '</br>Relative Rep. freq.: ',
        round(freq2, 4)
      )
    ) %>% dplyr::ungroup()
    
    loc2 <-
      setNames(1:length(unique(tmp_plot$v_allele_axis)), sort(unique(tmp_plot$v_allele_axis)))
    
    tmp_plot$loc2 <- loc2[tmp_plot$v_allele_axis]
    
    loc_jitter <-
      seq(0, 0.8, by = 0.8 / length(unique(tmp_plot$v_alleles_p)))
    
    loc_jitter <-
      setNames(loc_jitter, sort(unique(tmp_plot$v_alleles_p)))
    tmp_plot <-
      tmp_plot %>% arrange(loc2, v_alleles_p) %>% dplyr::group_by(loc2) %>% dplyr::mutate(loc_plot = loc2 + loc_jitter[v_alleles_p],) %>% dplyr::ungroup() %>% dplyr::mutate(jitter_offset = jitter(loc_plot))
    
    tickvals_tmp <-
      tmp_plot %>% pull(loc_plot) %>% unique() %>% sort()
    
    tickvals <- c()
    
    for (i in 1:length(loc2)) {
      tickvals <- c(tickvals, mean(tickvals_tmp[floor(tickvals_tmp) == i]))
    }
    
    
    ticktext <-
      tmp_plot %>% dplyr::pull(v_allele_axis) %>% unique() %>% sort()

    plotly1 <-
      tmp_plot %>% dplyr::rowwise() %>% dplyr::mutate(group = paste0(project, "-", v_alleles_p)) %>%
      highlight_key(., ~ subject) %>%
      plot_ly() %>%
      add_trace(
        type = "scatter",
        x = ~ (jitter_offset),
        y = ~ freq,
        text = ~ text,
        symbol = ~ project,
        mode = 'markers',
        marker = list(color = "grey", size = 12),
        showlegend = TRUE,
        opacity = 0.9,
        hoverinfo = 'none',
        legendgroup = ~ project
      ) %>%
      add_trace(
        type = "scatter",
        x = ~ (jitter_offset),
        y = ~ freq,
        text = ~ text,
        color = ~ v_alleles_p,
        mode = 'markers',
        showlegend = FALSE,
        opacity = 0.8,
        hoverinfo = 'text',
        legendgroup = ~ v_alleles_p
      ) %>%
      add_trace(
        x = ~ as.numeric(loc_plot),
        y = ~ freq,
        color = ~ v_alleles_p,
        type = "box",
        hoverinfo = "none",
        fillcolor = "transparent",
        name = ~ v_alleles_p,
        legendgroup = ~ v_alleles_p
      ) %>%
      layout(
        hovermode = 'closest',
        shapes = list(hline(input$allele_thresh/100)),
        legend = list(
          tracegroupgap = 20,
          title = list(text =
                         '<b>  </b>'),
          orientation = "V"
        ),
        xaxis = list(
          title = paste0(input$gene_group, " Alleles"),
          autotick = F,
          tickmode = "array",
          tickvals = tickvals,
          ticktext = ticktext
        ),
        yaxis = list(title = "Relative allele frequency")
      )  %>% plotly::highlight(
        on = "plotly_click",
        selected = attrs_selected(showlegend = FALSE),
        opacityDim = 0.3,
        persistent = TRUE
      ) %>% plotly_build()
    plotly1 %>% config(edits = list(shapePosition = TRUE),
                       scrollZoom = FALSE)
  })
    

  tableData = reactive({
    shiny::validate(need(
      nrow(plotData()) > 0,
      "No functional rearrangements were found for this selection."
    ))
    
    plotData() %>% rowwise() %>%
      dplyr::mutate(
        v_alleles = strsplit(strsplit(v_alleles, ";")[[1]][loc], paste0("^", loc, " -"))[[1]][2],
        loc = as.character(loc),
        zygousity_state = as.character(zygousity_state),
        freq = round(freq, 4),
        freq2 = round(freq2, 4),
        count = ifelse(input$decimal, round(count, 0), count)
      ) %>%
      select(project,
             subject,
             v_gene,
             v_alleles,
             count,
             freq,
             freq2)
  })
  
  
  
  output$table3 <- DT::renderDataTable(
    {if (input$btn_collapse) {
      tab <- DT::datatable(
        tableData(),
        extensions = 'RowGroup',
        options = list(rowGroup = list(dataSrc = 2), dom = "tipr"),
        callback = callback_js,
        selection = 'none',
        filter = list(
          position = "top",
          clear = TRUE,
          plain = FALSE
        ),
        colnames = c(
          "v gene" = "v_gene",
          "original\nallele" = "v_alleles",
          "number of \nassignments" = "count",
          "relative\nfraction" = "freq",
          "relative\nrepertoire\nfraction" = "freq2"
        )
      )
    } else{
      tab <- DT::datatable(
        tableData(),
        options = list(dom = "tipr"),
        selection = 'none',
        filter = list(
          position = "top",
          clear = TRUE,
          plain = FALSE
        ),
        colnames = c(
          "v gene" = "v_gene",
          "original\nallele" = "v_alleles",
          "number of \nassignments" = "count",
          "relative\nfraction" = "freq",
          "relative\nrepertoire\nfraction" = "freq2"
        )
      )
    }
      tab
    })

}

# shiny app --------------------------------------------------------------------

shinyApp(ui, server)






