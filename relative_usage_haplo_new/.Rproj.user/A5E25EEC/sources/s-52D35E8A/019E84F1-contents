#!/usr/bin/env Rscript
##################################################################################
##################################################################################
########################## Reprtoire Down-stream processing ######################
##################################################################################
##################################################################################

################################### libraries ####################################
suppressMessages(library(seqinr))
suppressMessages(library(tools))
suppressMessages(library(tigger))
suppressMessages(library(optparse))
suppressMessages(library(stringr))
suppressMessages(library(dplyr))
suppressMessages(library(data.table))
suppressMessages(library(alakazam))
suppressMessages(library(reshape2))
suppressMessages(library(shazam))
suppressMessages(library(rabhit))
suppressMessages(library(parallel))
suppressMessages(library(foreach))
suppressMessages(library(stringi))
suppressMessages(library(utils))

############################################# Constant parameters ###############################################
# IgBlast directory
igblast_dir <-
  '/private/tools/igblast/ncbi-igblast-1.16.0/bin/'  ## change to your igblast path
IGDATA <-
  '/private/tools/igblast/ncbi-igblast-1.16.0/' ## change to your igblast directory



# collapse seq script path
newcollapse_script_path <-
  "/localdata/peresay/scripts/collapse_seq_new.py" ## change to script location.

# customize tigger novel allele function
source("/localdata/peresay/scripts/functions_tigger.R") ## change to script location.

################################### functions ####################################
# \code{detect_cores} a warper function for detecting number of physical and virtual cores
# based on alakazam function
# physical             if Trure detects the physical number of cores.

detect_cores <- function(physical)
{
  if (.Platform$OS.type == "windows") {
    nproc <- parallel::detectCores(logical = physical)
  }
  else if (.Platform$OS.type == "unix") {
    nproc <-
      if (physical)
        system("grep '^cpu\\scores' /proc/cpuinfo | uniq |  awk '{print $4}'",
               intern = T)
    else
      parallel::detectCores()
  }
  else {
    nproc <- 1
  }
  if (is.na(nproc)) {
    nproc <- 1
  }
  return(nproc)
}

# Timestamped progress report
# from William Lees code
report = function(x,
                  value,
                  min,
                  max,
                  char = "=",
                  width = NA) {
  nw <- nchar(char, "w")
  x = paste0(">", Sys.time(), ':', x)
  x = paste(x, paste(rep.int(" ", 70L - nchar(x)), collapse = ""), collapse = "")
  if (is.na(width)) {
    width <- getOption("width")
    width <- width - 70L
    width <- trunc(width / nw)
  }
  pc <-  round(100 * (value - min) / (max - min))
  nb <- round(width * (value - min) / (max - min))
  cat(paste0(x,
             paste(
               c(
                 "|",
                 rep.int(char, nb),
                 rep.int(" ", nw * (width - nb)),
                 sprintf("| %3d%%", pc)
               ), collapse = ""
             ), '\n'))
}

# \code{tigger_uper_bound} Find the upper bound limit for novel alleles detection within dataset
# returns a list with the uppper limit range bound and genes
# DATA        makedb dataset.
tigger_uper_bound <- function(DATA) {
  ## select single assigment
  DATA <- DATA %>% dplyr::filter(!grepl(',', DATA$v_call)) %>%
    dplyr::select(v_call, v_germline_end) %>%
    dplyr::mutate(GENE = alakazam::getGene(v_call, strip_d = F)) %>%
    dplyr::group_by(GENE) %>% dplyr::mutate(RANGE = floor(quantile(v_germline_end, 0.05))) %>% dplyr::select(GENE, RANGE) %>%
    dplyr::slice(1) %>% dplyr::ungroup() %>% dplyr::group_by(RANGE) %>% dplyr::mutate(GENES = paste0(GENE, "[*]", collapse = "|")) %>%
    dplyr::slice(1) %>% dplyr::select(RANGE, GENES) %>% dplyr::ungroup()

  gene_range <- setNames(DATA$GENES, DATA$RANGE)
  return(gene_range)
}

# \code{run_igblast} a warper function for runing igblast from R
# igblast_dir          path for igblast directory;
# igdata_path          path for IGDATA needed for igblast run, where the internal_data/ resides. If null assumes the directory is under the igblast_dir
# num_alignments_V     numer of V annotations allowed; Default is 3.
# germline_db_V        gemline database for V.
# germline_db_D        gemline database for D.
# germline_db_J        gemline database for J.
# fasta_file_path      path for fasta file.
# fasta_file           name of fasta file in \code{fasta_file_path} directory.
# threads              number of threads allowed; Default is 1.
# out_path             path for output file. If no output path provided the file will be saved in the fasta file path.
# out_file             name of output file in \code{out_path} directory. Default output file name is igblast.out

run_igblast <-
  function(igblast_dir,
           igdata_path = NULL,
           num_alignments_V = NULL,
           germline_db_V,
           germline_db_D,
           germline_db_J,
           fasta_file_path,
           fasta_file,
           threads = 1,
           out_path = NULL,
           out_file = "igblast",
           airr = F,
           aux_file = NULL,
           ...) {
    if (is.null(out_path))
      out_path = fasta_file_path
    if (is.null(igdata_path))
      igdata_path = dirname(igblast_dir)
    if (!is.null(num_alignments_V)) {
      num_v = paste0(" -num_alignments_V ", num_alignments_V)
    } else{
      num_v = ""
    }
    if (airr) {
      format <- '19'
    } else{
      format <- "'7 std qseq sseq btop'"
    }
    arguments <- list(...)

    IGBLAST_RUN = paste0(
      igblast_dir,
      "/igblastn ",
      # path for igblast executable
      num_v,
      # number of Vs to align
      " -germline_db_V ",
      germline_db_V,
      # V reference database
      " -germline_db_J ",
      germline_db_J,
      # D reference database
      " -germline_db_D ",
      germline_db_D,
      # J reference database
      " -domain_system imgt",
      # Domain system to be used for segment annotation
      " -query '",
      fasta_file_path,
      "/",
      fasta_file,
      "'",
      # query file
      " -auxiliary_data ",
      ifelse(!is.null(aux_file), aux_file, paste0(dirname(igblast_dir),"/optional_file/human_gl.aux")),
      # path for igblast executable auxiliary data
      " -outfmt ",
      format,
      # out file format
      " -num_threads ",
      threads,
      # Number of threads to use
      " -out '",
      out_path,
      "/",
      out_file,
      "'",
      # Output file
      " ",
      arguments                                                                                     # Additional arguments for igblastn
    )
    ig_version = system(paste0(
      paste0("export IGDATA=", igdata_path, ";"),
      igblast_dir,
      "/igblastn -version"
    ), intern = T)[1]

    system(paste0(
      'export IGDATA=',
      igdata_path,
      ";",
      # exporting the path for IGDATA needed for igblast run
      #paste0('echo -e Running IgBlast version ', ig_version,';'),
      #paste0('echo -e Input file ', fasta_file,';')
      #'echo -e Starting run;',
      paste0('IGBLAST_RUN="', IGBLAST_RUN, '"; eval $IGBLAST_RUN;')
      #'echo -e Finished run;',
      #paste0('echo -e Output file ', out_path,"/",out_path,"")
    ),
    ignore.stdout = T)
  }

# \code{run_makedb} a warper function for runing makedb from R
# by makedb, file will be saved with the suffix _db-pass.tab
# igblast_file         igblast run file.
# fasta_file           fasta file used in igblast run.
# repo_file            refrence file of V and J annotations.
# out_path             path for output file. If not provided, than working directory is used.
# out_file             name of output file in \code{out_path} directory. If no name is provided the fasta file name is used.

run_makedb <-
  function(igblast_file,
           fasta_file,
           repo_file,
           out_path = getwd(),
           out_file = NULL,
           arg = "") {
    if (is.null(out_file))
      out_file <- tools::file_path_sans_ext(fasta_file)

    run <- paste0(
      'MakeDb.py igblast -i ',
      igblast_file,
      ' -s ',
      fasta_file,
      ' -r ',
      repo_file,
      ' --outdir ',
      out_path,
      ' --outname ',
      out_file,
      " ",
      arg
    )
    system(run, ignore.stdout = T)
  }

# \code{allele_diff} find the different position between sequences
allele_diff <- function(germs) {
  germs <- lapply(germs, function(x)
    strsplit(x, '')[[1]])
  germs_m <- t(sapply(germs, `length<-`, max(lengths(germs))))
  setdiff_mat <- function(x) {
    sum(!unique(x) %in% c('.', NA, "N"))#
  }
  idx = which(apply(germs_m, 2, setdiff_mat) > 1)
  return(idx)
}
getAlleles <- function(x) {
  tmp <- c()
  for (i in x) {
    tmp <- c(tmp, strsplit(i, '[*]')[[1]][2])
  }
  return(tmp)
}

# \code{reads2fasta} funtion creats a fasta file for from MakeDb dataset for igblast run.
# DATA                 Dataset with sequences and identifiers.
# out_path             path for writing the fasta file; If non is provided than working directory is used.
# out_file             name for the fasta file; Default is ig_fasta
# unique_information   columns with unique iformation to save. If non provided saves everything from JUNCTION

reads2fasta <-
  function(DATA,
           out_path = getwd(),
           out_file = "ig_fasta",
           unique_information = NULL,
           info_indx = "cdr3") {
    if (is.null(unique_information)) {
      info.strt.idx <- which(names(DATA) == info_indx)
      unique_information <-
        names(DATA)[(info.strt.idx + 1):ncol(DATA)]
    }
    invisible(gc(verbose = FALSE))
    unique_information <- c("sequence_id", unique_information)
    # create sequences names
    seq.names <-
      sapply(1:nrow(DATA), function(x) {
        paste0(unique_information,
               rep('=', length(unique_information)),
               DATA[x, unique_information],
               collapse = '|')
      })
    seq.names <- gsub('sequence_id=', '', seq.names, fixed = T)
    # taking the sequence input
    write.fasta(
      sequences = as.list(DATA$sequence),
      names = seq.names,
      paste0(out_path, '/', out_file, ".fasta"),
      open = "w"
    )
  }

getChain <-
  function (segment_call,
            first = TRUE,
            collapse = TRUE,
            strip_d = TRUE,
            omit_nl = FALSE,
            sep = ",")
  {
    gene_regex <- "((IG[HLK]|TR[ABGD]))"
    r <- getSegment(
      segment_call,
      gene_regex,
      first = first,
      collapse = collapse,
      strip_d = strip_d,
      omit_nl = omit_nl,
      sep = sep
    )
    return(r)
  }

Repeated_Read <- function(x, seq) {
  NT <- as.numeric(gsub("([0-9]+).*", '\\1', x))
  SNP <- gsub(".*>", '', x)
  OR_SNP <- gsub("[0-9]+([[:alpha:]]*).*", '\\1', x)
  seq <- c(substr(seq, (NT), (NT + 3)),
           substr(seq, (NT - 1), (NT + 2)),
           substr(seq, (NT - 2), (NT + 1)),
           substr(seq, (NT - 3), (NT)))
  PAT <- paste0(c(
    paste0(c(rep(SNP, 3), OR_SNP), collapse = ""),
    paste0(c(rep(SNP, 2), OR_SNP, SNP), collapse = ""),
    paste0(c(SNP, OR_SNP, rep(SNP, 2)), collapse = ""),
    paste0(c(OR_SNP, rep(SNP, 3)), collapse = "")
  ), collapse = "|")
  if (any(grepl(PAT, seq)))
    return(gsub(SNP, "X", gsub(OR_SNP, "z", seq[grepl(PAT, seq)])))
  else
    return(NA)
}

### user arguments

option_list = list(
  make_option(
    c("-f", "--file"),
    type = "character",
    default = NULL,
    help = "input file, either fasta or repertoire table file",
    metavar = "file",
    dest = "in_file"
  ),
  make_option(
    c("--sequence_id_column"),
    type = "character",
    default = "sequence_id",
    help = "sequence id column if table is input. Default is AIRR format: sequence_id",
    metavar = "column name",
    dest = "sequence_id"
  ),
  make_option(
    c("--sequence_column"),
    type = "character",
    default = "sequence",
    help = "sequence input column if table is input. Default is AIRR format: sequence",
    metavar = "column name",
    dest = "sequence_column"
  ),
  make_option(
    c("--consensus_count_column"),
    type = "character",
    default = "consensus_count",
    help = "consensus count column if table is input. Default is AIRR format: consensus_count",
    metavar = "column name",
    dest = "consensus_count"
  ),
  make_option(
    c("--c_call_column"),
    type = "character",
    default = "c_call",
    help = "c call or isotype column if table is input. Default is AIRR format: c_call",
    metavar = "column name",
    dest = "c_call"
  ),
  make_option(
    c("--unique_columns"),
    type = "character",
    default = NULL,
    help = "which columns to keep form input table, column names seperated by space.",
    metavar = "columns name",
    dest = "unique_columns"
  ),
  make_option(
    c("--v_call"),
    type = "character",
    default = "v_call",
    help = "v_call column if table is input. This column is used to filter sequences that match the chain. Default is AIRR format: v_call",
    metavar = "columns name",
    dest = "v_call"
  ),
  make_option(
    c("--chain"),
    type = "character",
    default = "IGH",
    help = "the repertoire chain",
    metavar = "chain",
    dest = "chain"
  ),
  make_option(
    c("-o", "--out.path"),
    type = "character",
    default = NULL,
    help = "out path for project directory. Default is file path.",
    metavar = "output path",
    dest = "out_path"
  ),
  make_option(
    c("-s", "--sample_name"),
    type = "character",
    default = NULL,
    help = "Sample name. Default is input file name.",
    metavar = "sample name",
    dest = "sample_name"
  ),
  make_option(
    c('--num_alignments_V'),
    type = 'integer',
    default = 10,
    help = "number of V alignments annotation igblast returns. Defualt is 10",
    dest = "num_alignments_V"
  ),
  make_option(
    c('--conscount_filter'),
    type = 'integer',
    default = 0,
    help = "Threshold filter for the consensus value. Default is above 2",
    dest = "conscount_filter"
  ),
  make_option(
    c('--short_reads'),
    action = "store_true",
    default = FALSE,
    help = "indicates if the sequence protocol produces short reads. Changes V region",
    dest = "short"
  ),
  make_option(
    c('-t', '--threads'),
    type = 'integer',
    default = 1,
    help = "nubmer of threads to use.",
    dest = "threads"
  ),
  make_option(
    c("--subsample"),
    action = "store_true",
    default = FALSE,
    help = "If to sample data before cloning.",
    dest = "sample"
  ),
  make_option(
    c("--subsample_size"),
    type = "numeric",
    default = 500,
    help = "Sample size for cloning.",
    dest = "sample_size"
  ),
  make_option(
    c('--clone_dist'),
    type = 'numeric',
    default = 0.2,
    help = "define threshold distance. Default is 0.2",
    dest = "clone_dist"
  ),
  make_option(
    c("--remove_interm_files"),
    action = "store_true",
    default = FALSE,
    help = "If to remove intermediate files. Defualt is a zip file with all intermediate analysis.",
    dest = "rm_files"
  ),
  make_option(
    c("--tar_interm_files"),
    action = "store_true",
    default = FALSE,
    help = "If to zip intermediate files. Defualt is a zip file with all intermediate analysis.",
    dest = "tar_files"
  ),
  make_option(
    c("--cloned_genotyped"),
    action = "store_true",
    default = FALSE,
    help = "If to infer clones for the genotyped data. Only for heavy chain sequences.",
    dest = "cloned_genotyped"
  ),
  make_option(
    c("--constant_parameters_file"),
    type = "character",
    default = "/localdata/peresay/scripts/constant_parameters_vdjbase.R",
    help = "Full path of the constant parameters file.",
    dest = "constant_parameters_file"
  ),
  make_option(
    c("--K_DIFF_FILTER"),
    type = "numeric",
    default = 1,
    help = "Filtering genotype calls which are less than the K diff supplied. Default is 1.",
    dest = "K"
  ),
  make_option(
    c("--start_from_novel"),
    action = "store_true",
    default = FALSE,
    help = "If to skip the first to steps, first alignment and clones.",
    dest = "start_from_novel"
  ),
  make_option(
    c("--start_from_last"),
    action = "store_true",
    default = FALSE,
    help = "If to skip the first to steps, first alignment and clones.",
    dest = "start_from_last"
  ),
  make_option(
    c("--germline_v_file"),
    type = "character",
    default = NULL,
    dest = "germline_v_file"
  ),
  make_option(
    c("--germline_d_file"),
    type = "character",
    default = NULL,
    dest = "germline_d_file"
  ),
  make_option(
    c("--germline_j_file"),
    type = "character",
    default = NULL,
    dest = "germline_j_file"
  ),
  make_option(
    c("--aux_file"),
    type = "character",
    default = NULL,
    dest = "aux_file"
  )

)

opt = parse_args(OptionParser(usage = "%prog [options] file", option_list =
                                option_list))

### if file is null exit

if (is.null(opt$in_file)) {
  stop(
    cat(
      "Error: you must provide either a fasta file or a Change-O database file with the -f option"
    )
  )
}


### parser variables
in_file <- opt$in_file
sequence_id <- opt$sequence_id
sequence_column <- opt$sequence_column
consensus_count <- opt$consensus_count
c_call <- opt$c_call
unique_columns <- opt$unique_columns
v_call <- opt$v_call
chain <- opt$chain
out_path <- opt$out_path
sample_name <- opt$sample_name
num_alignments_V <- opt$num_alignments_V
short <- opt$short
threads <- opt$threads
sample <- opt$sample
sample_size <- opt$sample_size
clone_dist <- opt$clone_dist
rm_files <- opt$rm_files
tar_files <- opt$tar_files
cloned_genotyped <- opt$cloned_genotyped
conscount_filter <- opt$conscount_filter
K <- opt$K_DIFF_FILTER
start_from_novel <- opt$start_from_novel
start_from_last <- opt$start_from_last
germline_v_file <- opt$germline_v_file
germline_d_file <- opt$germline_d_file
germline_j_file <- opt$germline_j_file
aux_file <- opt$aux_file
### check input file and parse
if (!file_ext(in_file) %in% c("fasta", "tab", "tsv", "csv"))
  stop(
    cat(
      "Input file format is incorrect. Please input one of: sample.fasta, sample.tab, sample.tsv, sample.csv"
    )
  )

if (chain %in% c("IGL", "IGK", "TRA")) {
  cat("Warning - Light chain sequences, no clone inference and sampling will be done\n")

  sample <- FALSE
  cloned_genotyped <- FALSE
  short <- F
}
#pb <- txtProgressBar(min = 0, max = ifelse(cloned_genotyped, 9, 7), style = 3)

report(
  x = "Pipeline started",
  value = 0,
  min = 0,
  max = ifelse(cloned_genotyped, 9, 7)
)
### create sample directory
sample_name <-
  ifelse(is.null(sample_name),
         tools::file_path_sans_ext(basename(in_file)),
         sample_name)
out_path <-
  file.path(ifelse(is.null(out_path), dirname(out_path), out_path), sample_name)
dir.create(out_path, showWarnings = F)


if (!is.null(germline_v_file)) {
  file.copy(germline_v_file, file.path(out_path, basename(germline_v_file)))
  file.copy(paste0(tools::file_path_sans_ext(germline_v_file),"_gapped.fasta"), file.path(out_path, basename(paste0(tools::file_path_sans_ext(germline_v_file),"_gapped.fasta"))))
  file.copy(germline_d_file, file.path(out_path, basename(germline_d_file)))
  file.copy(germline_j_file, file.path(out_path, basename(germline_j_file)))

  system(
    paste0(
      igblast_dir,
      '/makeblastdb -parse_seqids -dbtype nucl -in ',
      germline_v_file,
      ' -out ',
      file.path(out_path, basename(
        tools::file_path_sans_ext(germline_v_file)
      ))
    )
  )

  system(
    paste0(
      igblast_dir,
      '/makeblastdb -parse_seqids -dbtype nucl -in ',
      germline_d_file,
      ' -out ',
      file.path(out_path, basename(
        tools::file_path_sans_ext(germline_d_file)
      ))
    )
  )

  system(
    paste0(
      igblast_dir,
      '/makeblastdb -parse_seqids -dbtype nucl -in ',
      germline_j_file,
      ' -out ',
      file.path(out_path, basename(
        tools::file_path_sans_ext(germline_j_file)
      ))
    )
  )

  germline_v_file <- file.path(out_path, basename(germline_v_file))
  germline_d_file <- file.path(out_path, basename(germline_d_file))
  germline_j_file <- file.path(out_path, basename(germline_j_file))

  germline_db_V <-
    file.path(out_path, basename(
      tools::file_path_sans_ext(germline_v_file)
    ))

  germline_db_D <-
    file.path(out_path, basename(
      tools::file_path_sans_ext(germline_d_file)
    ))

  germline_db_J <-
    file.path(out_path, basename(
      tools::file_path_sans_ext(germline_j_file)
    ))

  germline_v_file <- paste0(tools::file_path_sans_ext(germline_v_file),"_gapped.fasta")

  VGERM_PATH <- germline_v_file
  VGERM <- tigger::readIgFasta(VGERM_PATH)

  DGERM_PATH <- germline_d_file
  DGERM <- tigger::readIgFasta(DGERM_PATH)

  JGERM_PATH <- germline_j_file
  JGERM <- tigger::readIgFasta(JGERM_PATH)

  MAKEDBREPO <- paste(VGERM_PATH, DGERM_PATH, JGERM_PATH)
}
print(germline_db_V)
print(VGERM_PATH)

#### check if fasta or table was input and create fasta file if needed
if (file_ext(in_file) != "fasta") {
  ###### check if to use parsedb from changeo #####
  if (!is.null(unique_columns)) {
    unique_columns <- unlist(strsplit(unique_columns, " "))
    columns <- c(sequence_id,
                 sequence_column,
                 v_call,
                 consensus_count,
                 c_call,
                 unique_columns)
  } else{
    columns <-
      c(sequence_id,
        sequence_column,
        v_call,
        consensus_count,
        c_call)
  }

  ## read file with relevant columns
  data <-
    data.table::fread(
      in_file,
      header = T,
      select = columns,
      stringsAsFactors = F,
      data.table = F
    )
  ##filter data to match the chain
  data <- data[grepl(chain, data[[v_call]]), ]
  if (nrow(data) <= 100) {
    stop(print(
      "Not enough sequences matched the given chain, less than 100 sequences."
    ))
    unlink(out_path, recursive = T)
  } else{
    cat(paste0(nrow(data), " Were retrieved from the input table", "\n"))
  }
  # remove v_call column
  data <- data[, names(data) != v_call]
  columns <- columns[-3]
  ## change sequence_column, consensus_count, and c_call column names
  names(data)[which(names(data) == consensus_count)] <-
    "consensus_count"
  names(data)[which(names(data) == c_call)] <- "c_call"

  columns[which(columns == consensus_count)] <- "consensus_count"
  columns[which(columns == c_call)] <- "c_call"

  cat(paste0(
    "These columns are saved to the fasta file: ",
    paste0(columns, collapse = ", "),
    "\n"
  ))
  ## create fasta file
  seq.names <- sapply(1:nrow(data), function(x) {
    paste0(columns,
           rep('=', length(columns)),
           data[x, columns],
           collapse = '|')
  })
  seq.names <-
    gsub(paste0(sequence_id, '='), '', seq.names, fixed = T)

  fasta_file <- file.path(out_path, paste0(sample_name, ".fasta"))
  tigger::writeFasta(setNames(data[[sequence_column]], seq.names), fasta_file)
  fileSize <- nrow(data)
  remove(data, seq.names)
} else{
  fasta_file <- in_file
  fileSize <-
    as.numeric(system(paste0("grep -c '^>' ", fasta_file), intern = T))
}

### if number of sequences is lower than 100 quit run.
if (fileSize <= 100) {
  stop(print("Not enough sequences, lower than 100."))
  unlink(out_path, recursive = T)
}

##################################################################################
########################## Section one ###########################################
##################################################################################
## first sections includes IgBlast alignment, MakeDb and sequence collapse.
### change working direcory
setwd(out_path)

### end section file
collapsed_file = file.path(out_path, paste0(sample_name, "_collapsed.tsv"))

# ### detect number of cores for MakeDb


#threads_parallel <- min(round((as.numeric(detect_cores(F))-4)/4),threads)


vnproc <- alakazam::cpuCount() - 1 # virtual
nproc <- as.numeric(detect_cores(T)) - 1 # physical
threads_parallel <- max(1, min(threads, nproc))

# split sequences for igblast run, number of files is set to the number of "physical" cores
# create a temp dir for split files


if (dir.exists(file.path(out_path, "tmpf")))
  system(paste0("rm -rf ", file.path(out_path, "tmpf")))

dir.create(file.path(out_path, "tmpf"), showWarnings = F)
tmp_dir <- file.path(out_path, "tmpf")

report(
  x = paste0(fileSize, " Sequences were found, aligning sequences"),
  value = 1,
  min = 0,
  max = ifelse(cloned_genotyped, 9, 7)
)

# get split size.
split = T
if (fileSize > 50000) {
  fileSize <- round(fileSize / 5)
  split = T
}


system(
  paste0(
    "SplitSeq.py count -s ",
    fasta_file,
    " --outdir ",
    tmp_dir,
    " -n ",
    fileSize
  ),
  ignore.stdout = T
)

# list files and split to clusters
tmp_files <- list.files(tmp_dir, "*.fasta$", full.names = T)
print(MAKEDBREPO)
if (split) {
  cluster <- parallel::makeCluster(nproc, type = "FORK")
  doParallel::registerDoParallel(cluster)
  invisible(foreach(f = tmp_files, .verbose = F)  %dopar% {
    name <- gsub("[.]fasta", "", basename(f))
    file_ig <- paste0(name, ".out")
    run_igblast(
      igblast_dir,
      igdata_path = IGDATA,
      num_alignments_V,
      germline_db_V,
      germline_db_D,
      germline_db_J,
      fasta_file_path = dirname(f),
      fasta_file = basename(f),
      threads = threads_parallel,
      out_path = tmp_dir,
      out_file = file_ig,
      airr = F
    )
  })
  cat("finished alignment going into makedb")
  invisible(foreach(f = tmp_files, .verbose = F) %dopar% {
    name <- gsub("[.]fasta", "", basename(f))
    file_ig <- paste0(name, ".out")
    run_makedb(
      igblast_file = file.path(tmp_dir, file_ig),
      fasta_file = f,
      repo_file = MAKEDBREPO,
      out_path = tmp_dir,
      arg = " --extended"
    )
  })
  stopCluster(cluster)
} else{
  name <- gsub("[.]fasta", "", basename(tmp_files))
  file_ig <- paste0(name, ".out")

  run_igblast(
    igblast_dir,
    igdata_path = IGDATA,
    num_alignments_V,
    germline_db_V,
    germline_db_D,
    germline_db_J,
    fasta_file_path = dirname(tmp_files),
    fasta_file = basename(tmp_files),
    threads = threads,
    out_path = tmp_dir,
    out_file = file_ig,
    airr = F
  )
  cat("finished alignment going into makedb")
  run_makedb(
    igblast_file = file.path(tmp_dir, file_ig),
    fasta_file = tmp_files,
    repo_file = MAKEDBREPO,
    out_path = tmp_dir,
    arg = " --extended"
  )

}
### collapse sequences
report(
  x = "collapsing sequences",
  value = 1,
  min = 0,
  max = ifelse(cloned_genotyped, 9, 7)
)
system(paste0(
  'python ',
  newcollapse_script_path,
  " ",
  paste(
    tmp_dir,
    "'*_db-pass.tsv'",
    collapsed_file,
    chain,
    conscount_filter
  )
))

### check if collpased file was created; if not stop run
if (!file.exists(collapsed_file))
  stop(print(
    paste0(
      "Failed section one. ",
      sample_name,
      "_collapsed.tsv file was not created."
    )
  ))
#if (dir.exists(file.path(out_path, "tmpf")))
#  system(paste0("rm -rf ", file.path(out_path, "tmpf")))
### check if there are more than 100 sequence; if not stop run
if (as.numeric(strsplit(system(
  paste0("wc -l ", collapsed_file), intern = T
), " ")[[1]][1]) <= 100) {
  stop(print("Not enough sequences, lower than 100."))
  unlink(out_path, recursive = T)
}
# report(
#   x = "inferring clones",
#   value = 2,
#   min = 0,
#   max = ifelse(cloned_genotyped, 9, 7)
# )

##################################################################################
########################## Section two ###########################################
##################################################################################
## Second sections includes cluster sequences.

## if light chain then no cluster
# if (!chain %in% c("IGL", "IGK", "TRA")) {
#   ### end section file
#   clone_file <-
#     file.path(out_path, paste0(sample_name, "_single_clone.tsv"))
#
#   ### create subsample clone file
#   DATA <-
#     data.table::fread(
#       collapsed_file,
#       stringsAsFactors = F,
#       verbose = F,
#       data.table = F,
#       showProgress = F
#     )
#
#   ### write final igblast
#   info_indx = "cdr3"
#   info.strt.idx <- which(names(DATA) == info_indx)
#   unique_information <-
#     names(DATA)[(info.strt.idx + 1):ncol(DATA)]
#   unique_information <-
#     grep("sequence_",
#          unique_information,
#          invert = T,
#          value = T)
#   unique_information <- c("sequence_id", unique_information)
#   seq.names <-
#     sapply(1:nrow(DATA), function(x) {
#       paste0(unique_information,
#              rep('=', length(unique_information)),
#              DATA[x, unique_information],
#              collapse = '|')
#     })
#   seq.names <- gsub('sequence_id=', '', seq.names, fixed = T)
#
#   fasta_file <-
#     file.path(out_path, paste0(sample_name, "_last_igblast.fasta"))
#   tigger::writeFasta(setNames(DATA[["sequence"]], seq.names), fasta_file)
#
#
#   if (sample) {
#     ### make sure that all sequences have V, D, and J call
#     calls <-
#       unlist(strsplit(
#         ifelse(
#           chain %in% c("IGL", "IGK", "TRA"),
#           "v_call,j_call",
#           "v_call,j_call,d_call"
#         ),
#         ","
#       ))
#     ### read collaped file and filter
#     for (call in calls) {
#       DATA <- DATA[grepl(toupper(substr(call, 1, 1)), DATA[[call]]),]
#     }
#     ### filter productive sequences
#     DATA <- DATA[DATA$productive %in% c(TRUE, "T", "TRUE"),]
#
#     ### sample X sequences per V gene.
#     DATA$v_gene <-
#       getGene(
#         DATA$v_call,
#         first = F,
#         collapse = T,
#         strip_d = T
#       )
#     genes <- unique(getGene(names(VGERM), strip_d = T))
#     ids <- unlist(sapply(genes, function(g) {
#       id <- grep(g, DATA$v_gene, fixed = T)
#       id_l <-
#         if (sample_size <= 1)
#           length(id) * sample_size
#       else if (sample_size > length(id))
#         length(id)
#       else
#         sample_size
#       sample(id, id_l)
#     }))
#     DATA <- DATA[ids, ]
#   } else{
#     DATA$v_gene <-
#       getGene(
#         DATA$v_call,
#         first = F,
#         collapse = T,
#         strip_d = T
#       )
#   }
#   ### write file for defineclone
#   tmp_clone_file <-
#     file.path(out_path, paste0(sample_name, "_for_clone_1st.tsv"))
#   write.table(
#     DATA,
#     file = tmp_clone_file,
#     row.names = FALSE,
#     quote = FALSE,
#     sep = '\t'
#   )
#
#   system(
#     paste0(
#       'nice -19 CreateGermlines.py ',
#       " -d ",
#       tmp_clone_file,
#       " --outdir ",
#       out_path,
#       " -g dmask ",
#       " -r ",
#       paste(VGERM_PATH, DGERM_PATH, JGERM_PATH),
#       " --outname ",
#       sample_name
#     ),
#     ignore.stdout = T
#   )
#
#   tmp_clone_file <-
#     file.path(out_path, paste0(sample_name, "_germ-pass.tsv"))
#   system(
#     paste0(
#       ' DefineClones.py ',
#       " -d ",
#       tmp_clone_file,
#       " --model hh_s5f",
#       " --dist ",
#       round(clone_dist, 3),
#       " --mode gene --vf v_gene",
#       " --norm len",
#       " --act set",
#       " --sym min",
#       " --outdir ",
#       out_path,
#       " --outname ",
#       sample_name,
#       " --nproc ",
#       threads
#     ),
#     ignore.stdout = T
#   )
#
#   tmp_clone_file <-
#     file.path(out_path, paste0(sample_name, "_clone-pass.tsv"))
#   system(
#     paste0(
#       'nice -19 CreateGermlines.py ',
#       " -d ",
#       tmp_clone_file,
#       " --outdir ",
#       out_path,
#       " -g dmask ",
#       " -r ",
#       paste(VGERM_PATH, DGERM_PATH, JGERM_PATH),
#       " --cloned"
#     ),
#     ignore.stdout = T
#   )
#
#   tmp_clone_file <-
#     file.path(out_path,
#               paste0(sample_name, "_clone-pass_germ-pass.tsv"))
#
#   DATA <-
#     suppressWarnings(alakazam::readChangeoDb(tmp_clone_file))
#   cat(paste0("Note ", nrow(DATA), " sequences after collapse clones\n"))
#   cluster <-
#     parallel::makeCluster(threads_parallel, type = "FORK")
#   #Export cluster
#   parallel::clusterExport(cl = cluster,
#                           c("allele_diff", "DATA"),
#                           envir =
#                             environment())
#   # calculating mutation between IMGT sequence and the germline sequence, selecting a single sequence to each clone with the fewest mutations
#   DATA$mut <-
#     parSapply(cluster, 1:nrow(DATA), function(i)
#       length(allele_diff(DATA[i, c('sequence_alignment', 'germline_alignment_d_mask')])))
#   if (threads_parallel > 1) {
#     stopCluster(cluster)
#   }
#   # filter to the fewest mutations
#   DATA <- DATA %>% group_by(clone_id) %>% mutate(clone_size = n())
#   DATA <-
#     as.data.frame(DATA %>% group_by(clone_id) %>% slice(which.min(mut)))
#   cat(paste0(
#     "Note ",
#     nrow(DATA),
#     " sequences after selecting single representative\n"
#   ))
#   ## write section end file
#   write.table(
#     DATA,
#     file = clone_file,
#     row.names = FALSE,
#     quote = FALSE,
#     sep = '\t'
#   )
# } else{
cat(paste0(
  "Warning - no clone inference is created for light chains\n",
  collapse = ""
))
DATA <-
  data.table::fread(
    collapsed_file,
    stringsAsFactors = F,
    verbose = F,
    data.table = F,
    showProgress = F
  )
### write final igblast
info_indx = "cdr3"
info.strt.idx <- which(names(DATA) == info_indx)
unique_information <-
  names(DATA)[(info.strt.idx + 1):ncol(DATA)]
unique_information <-
  grep("sequence_",
       unique_information,
       invert = T,
       value = T)
unique_information <- c("sequence_id", unique_information)
seq.names <-
  sapply(1:nrow(DATA), function(x) {
    paste0(unique_information,
           rep('=', length(unique_information)),
           DATA[x, unique_information],
           collapse = '|')
  })
seq.names <- gsub('sequence_id=', '', seq.names, fixed = T)

fasta_file <-
  file.path(out_path, paste0(sample_name, "_last_igblast.fasta"))
tigger::writeFasta(setNames(DATA[["sequence"]], seq.names), fasta_file)

# }

report(
  x = "inferring novel alleles",
  value = 3,
  min = 0,
  max = ifelse(cloned_genotyped, 9, 7)
)

##################################################################################
########################## Section Three #########################################
##################################################################################
## Third sections includes novel alleles inference.


##################################################################################
########################## Section Three #########################################
##################################################################################
## Third sections includes novel alleles inference.



gene_range <- tigger_uper_bound(DATA)
novel_df <- c()
for (i in 1:length(gene_range)) {
  upper_range <- as.numeric(names(gene_range)[i]) - 2
  genes <- gene_range[i]
  sub_ <- DATA[stringi::stri_detect_regex(DATA$v_call, genes), ]
  if (nrow(sub_) != 0) {
    low_range <-
      min(sapply(sub_$sequence_alignment, function(x)
        stringr::str_locate(x, "[ATCG]")[[1]]))
    novel_df_tmp =  try(findNovelAlleles(
      data = sub_,
      germline_db = VGERM,
      pos_range = low_range:upper_range,
      v_call = "v_call",
      j_call = "j_call" ,
      seq = "sequence_alignment",
      junction = "junction",
      junction_length = "junction_length",
      germline_min = 1,
      min_seqs = 1,
      nproc = nproc
    ))
    if (class(novel_df) != "try-error") {
      novel_df <- bind_rows(novel_df, novel_df_tmp)
    }
  }
}
# select only the novel alleles


novel_df <- tigger::selectNovel(novel_df)
novel_df <- novel_df[!is.na(novel_df$novel_imgt), ]
novel_df <- novel_df[!duplicated(novel_df$novel_imgt), ]
novel_df <-
  novel_df %>% mutate(gene = alakazam::getGene(germline_call, strip_d = F)) %>%
  group_by(gene) %>% top_n(n = 2, wt = novel_imgt_count)

## remove padded alleles

Repeated_Read <- function(x,seq){
  NT <- as.numeric(gsub("([0-9]+).*",'\\1',x))
  SNP <- gsub(".*>",'',x)
  OR_SNP <- gsub("[0-9]+",'\\1',gsub(">.*",'',x))
  seq <- c(substr(seq,(NT),(NT+3)),substr(seq,(NT-1),(NT+2)),
           substr(seq,(NT-2),(NT+1)),substr(seq,(NT-3),(NT)))
  PAT <- paste0(c(paste0(c(rep(SNP,3),OR_SNP),collapse = ""),
                  paste0(c(rep(SNP,2),OR_SNP,SNP),collapse = ""),
                  paste0(c(SNP,OR_SNP,rep(SNP,2)),collapse = ""),
                  paste0(c(OR_SNP,rep(SNP,3)),collapse = "")), collapse = "|")
  if( any(grepl(PAT,seq))) return(paste0(gsub(SNP,"X",gsub(OR_SNP,"z",seq[grepl(PAT,seq)])),collapse = "^"))
  else return(NA)
}

if (nrow(novel_df) != 0) {
  SNP_XXXX <- unlist(sapply(1:nrow(novel_df), function(i) {
    subs <- strsplit(novel_df$nt_substitutions[i], ',')[[1]]
    RR <-
      sapply(subs,
             Repeated_Read,
             seq = novel_df$germline_imgt[i],
             simplify = F)
    RR <- RR[RR != "NA"]

    length(RR) != 0
  }))

  novel_df <- novel_df[!SNP_XXXX, ]
}

cat(paste0(
  "Found these novel sequences ",
  paste0(novel_df$polymorphism_call, collapse = ","),
  "\n"
))

# re-align sequences with novel alleles
if (nrow(novel_df) > 0) {
  novel_df <- novel_df[!duplicated(novel_df), ]
  novel_df <- novel_df[novel_df$nt_substitutions != '', ]

  cat(paste0("Found ", nrow(novel_df), " candidates novel alleles\n"))
  ## re-aligne the dataset with the novel alleles

  # create germline reference for igblast and makedb
  novel_genotype <- novel_df$novel_imgt
  novel_genotype <-
    sapply(novel_genotype, function(x) {
      gsub('-', '.', x, fixed = T)
    })
  names(novel_genotype) <- novel_df$polymorphism_call

  #Remove duplicated novel allele names
  novel_genotype <-
    novel_genotype[!duplicated(names(novel_genotype))]

  ## check for chimera sequences, for high probability re-align all assignments and discard sequences.
  ## repeat clone step and novel alleles.
  VGERM_2nd <- VGERM
  #chimera_alleles <- chimera_check(VGERM_2nd, novel_df)
  ###### filter chimera sequences #####

  write.table(
    novel_df,
    file = file.path(out_path, paste0(sample_name, '_novel_dataframe.tsv')),
    row.names = FALSE,
    quote = FALSE,
    sep = '\t'
  )
  VGERM_2nd <- c(VGERM, novel_genotype)

  cat(paste0("Align novel alleles", "\n"))
  write.fasta(
    sequences = as.list(VGERM_2nd),
    names = names(VGERM_2nd),
    file.path(out_path, "V_extended_ref_gapped_unchanged.fasta"),
    open = "w"
  )

  len_names <-
    sapply(1:length(names(VGERM_2nd)), function(x)
      if (nchar(names(VGERM_2nd)[x]) > 50) {
        tmp <- strsplit(names(VGERM_2nd)[x], '[_]')[[1]][1]
        return(paste0(tmp, '_', x))
      } else{
        return(names(VGERM_2nd)[x])
      })
  names(len_names) <- names(VGERM_2nd)
  names(VGERM_2nd) <- len_names

  ## create the reference for the second igblast. shorten the names of long allele.
  tigger::writeFasta(gsub("[.]", "", VGERM_2nd),
                     file.path(out_path, "V_extended_ref_ungapped.fasta"))

  tigger::writeFasta(VGERM_2nd,
                     file.path(out_path, "V_extended_ref.fasta"))
  # create balst db
  system(
    paste0(
      paste0("export IGDATA=", IGDATA, ";"),
      # TODO see if needed
      igblast_dir,
      '/makeblastdb -parse_seqids -dbtype nucl -in ',
      out_path,
      '/',
      'V_extended_ref_ungapped.fasta -out ',
      out_path,
      '/V_extended_ref'
    ),
    ignore.stdout = T
  )

  VGERM_PATH2 = file.path(out_path, "V_extended_ref.fasta")


  # create fasta file for igblast
  idx <-
    grep(paste0(
      alakazam::getGene(novel_df$germline_call),
      "[*]",
      collapse = "|"
    ),
    DATA$v_call)

  columns_ <- c("duplicate_count", "consensus_count", "c_call")
  #if (chain %in% c("IGH", "TRB"))
  #  columns_ <- c(columns_, "clone_size", "clone_id")
  reads2fasta(
    as.data.frame(DATA[idx, ]),
    out_path = out_path,
    out_file = paste0(sample_name, "_novel_alleles_ids"),
    unique_information = columns_
  )

  # run igblast
  run_igblast(
    igblast_dir,
    igdata_path = IGDATA,
    num_alignments_V,
    file.path(out_path, "V_extended_ref"),
    germline_db_D,
    germline_db_J,
    fasta_file_path = out_path,
    fasta_file = paste0(sample_name, "_novel_alleles_ids.fasta"),
    threads = threads,
    out_path = out_path,
    out_file = paste0(sample_name, "_novel_realigned.out"),
    airr = F
  )

  if (chain %in% c("IGH", "TRB")) {
    MAKEDBREPO <- paste(VGERM_PATH2, DGERM_PATH, JGERM_PATH)
  } else{
    MAKEDBREPO <- paste(VGERM_PATH2, " ", JGERM_PATH)
  }
  run_makedb(
    igblast_file = file.path(out_path, paste0(sample_name, "_novel_realigned.out")),
    fasta_file = file.path(out_path,
                           paste0(
                             sample_name, "_novel_alleles_ids.fasta"
                           )),
    repo_file = MAKEDBREPO,
    out_path = out_path,
    arg = " --extended"
  )

  DATA_sub <-
    alakazam::readChangeoDb(file.path(
      out_path,
      paste0(sample_name, "_novel_alleles_ids_db-pass.tsv")
    ))

  DATA_sub <-
    DATA_sub %>% filter(productive %in% c("TRUE", "T", "True", T, TRUE))

  if (length(len_names[grep("_[0-9]", len_names)]) != 0) {
    new_names <- len_names[grep("_[0-9]", len_names)]
    for (n in new_names) {
      ids <- grep(n, DATA_sub$v_call, fixed = T)
      DATA_sub$v_call[ids] <-
        gsub(n, names(new_names)[new_names == n], DATA_sub$v_call[ids], fixed = T)
      ids <- grep(n, DATA$v_call, fixed = T)
      DATA$v_call[ids] <-
        gsub(n, names(new_names)[new_names == n], DATA$v_call[ids], fixed = T)


      names(VGERM_2nd)[names(VGERM_2nd) == n] <-
        names(new_names)[new_names == n]
    }
  }
  DATA <-
    data.table::rbindlist(list(DATA[-idx, ], DATA_sub), fill = T)

  VGERM_PATH2 = file.path(out_path, "V_extended_ref_gapped_unchanged.fasta")

  genotype_file = file.path(out_path, paste0(sample_name, "_single_clone_novel.tsv"))
  write.table(
    DATA,
    file = genotype_file,
    row.names = FALSE,
    quote = FALSE,
    sep = '\t'
  )
  remove(DATA_sub)
  invisible(gc(verbose = FALSE))
} else{
  VGERM_PATH2 <- VGERM_PATH
  genotype_file =  file.path(out_path, paste0(sample_name, "_single_clone.tsv"))
  if (chain %in% c("IGL", "IGK", "TRA"))
    genotype_file  =  file.path(out_path, paste0(sample_name, "_collapsed.tsv"))
}

### check if genotype file was created; if not stop run
if (!file.exists(genotype_file))
  stop(print(
    paste0(
      "Failed section three. ",
      sample_name,
      "_single_clone.tsv file was not created."
    )
  ))

report(
  x = "inferring genotype",
  value = 4,
  min = 0,
  max = ifelse(cloned_genotyped, 9, 7)
)

##################################################################################
########################## Section Four ##########################################
##################################################################################
## Fourth section includes genotype and haplotype inferences.

VGERM <- read.fasta(VGERM_PATH2, as.string = TRUE)
if (sum(grepl('|', names(VGERM), fixed = T)))
  names(VGERM) <-
  sapply(strsplit(names(VGERM), "|", fixed = T), "[", 2)
VGERM <- toupper(unlist(VGERM))

# get the genotype alleles
GENOTYPED_ALLELES <- function(y) {
  m <- which.max(as.numeric(y[2:5]))

  paste0(unlist(strsplit((y[1]), ','))[1:m], collapse = ",")
}

param <- c(0.6, 0.4, 0.4, 0.35, 0.25, 0.25, 0.25, 0.25, 0.25)
genoV <-
  tigger::inferGenotypeBayesian(
    DATA,
    # including multiple assignment,
    find_unmutated = FALSE,
    germline_db = VGERM,
    priors = param,
    v_call = 'v_call',
    seq = "sequence_alignment"
  )
genoV$GENOTYPED_ALLELES <-
  apply(genoV[, c(2, 6:9)], 1, function(y) {
    GENOTYPED_ALLELES(y)
  })

## Remove irrelevant alleles from germline
cat(paste0(sum(grepl(
  "_", genoV$GENOTYPED_ALLELES
)) , " novel alleles entered the genotype\n"))
# VGERM
#genoV_K <- genoV[genoV$k_diff >= K,]
NOTGENO.IND <-
  !(sapply(strsplit(names(VGERM), '*', fixed = T), '[', 1) %in%  genoV$gene)
VGERM.NEW <- VGERM[NOTGENO.IND]
for (i in 1:nrow(genoV)) {
  gene <- genoV$gene[i]
  alleles <- genoV$GENOTYPED_ALLELES[i]
  alleles <- grep("_", unlist(strsplit(alleles, ',')), value = T)
  IND <- names(VGERM) %in%  paste(gene, alleles, sep = '*')
  VGERM.NEW <- c(VGERM.NEW, VGERM[IND])
}

# writing imgt gapped fasta reference
write.fasta(
  sequences = as.list(VGERM.NEW),
  names = names(VGERM.NEW),
  paste0(out_path,
         '/',
         sample_name,
         "_V_personal_ref_unchanged.fasta"),
  open = "w"
)

VGERM.NEW.SHORT <- VGERM.NEW
len_names <-
  sapply(1:length(names(VGERM.NEW.SHORT)), function(x)
    if (nchar(names(VGERM.NEW)[x]) > 50) {
      tmp <- strsplit(names(VGERM.NEW)[x], '[_]')[[1]][1]
      return(paste0(tmp, '_', x))
    } else{
      return(names(VGERM.NEW.SHORT)[x])
    })
names(len_names) <- names(VGERM.NEW.SHORT)
names(VGERM.NEW.SHORT) <- len_names

# writing imgt gapped fasta reference
write.fasta(
  sequences = as.list(VGERM.NEW.SHORT),
  names = names(VGERM.NEW.SHORT),
  paste0(out_path, '/', sample_name, "_V_personal_ref_gapped.fasta"),
  open = "w"
)


write.fasta(
  sequences = as.list(gsub("[.]", "", VGERM.NEW.SHORT)),
  names = names(VGERM.NEW.SHORT),
  paste0(out_path,
         '/',
         sample_name,
         "_V_personal_ref_ungapped.fasta"),
  open = "w"
)

# create balst db
system(
  paste0(
    paste0("export IGDATA=", IGDATA, ";"),
    # TODO see if needed
    igblast_dir,
    '/makeblastdb -parse_seqids -dbtype nucl -in ',
    out_path,
    '/',
    sample_name,
    '_V_personal_ref_ungapped.fasta -out ',
    out_path,
    '/V_personal_ref'
  ),
  ignore.stdout = T
)

param <- c(0.5, 0.5, 0, 0, 0, 0, 0, 0, 0)
genoJ <-
  tigger::inferGenotypeBayesian(
    DATA[!grepl(pattern = ',', DATA$j_call), ],
    # ignoring multiple assignments
    find_unmutated = FALSE,
    germline_db = JGERM,
    priors = param,
    v_call = 'j_call',
    seq = "sequence_alignment"
  )
# get the genotype alleles
genoJ$GENOTYPED_ALLELES <-
  apply(genoJ[, c(2, 6:9)], 1, function(y) {
    GENOTYPED_ALLELES(y)
  })

NOTGENO.IND <-
  !(sapply(strsplit(names(JGERM), '*', fixed = T), '[', 1) %in%  genoJ$gene)
genoJ.NEW <- JGERM[NOTGENO.IND]
for (i in 1:nrow(genoJ)) {
  gene <- genoJ$gene[i]
  alleles <- genoJ$GENOTYPED_ALLELES[i]
  alleles <- unlist(strsplit(alleles, ','))
  IND <- names(JGERM) %in%  paste(gene, alleles, sep = '*')
  genoJ.NEW <- c(genoJ.NEW, JGERM[IND])
}

# writing imgt gapped fasta reference
write.fasta(
  sequences = as.list(genoJ.NEW),
  names = names(genoJ.NEW),
  paste0(out_path, '/', sample_name, "_J_personal_ref.fasta"),
  open = "w"
)

# create balst db
system(
  paste0(
    paste0("export IGDATA=", IGDATA, ";"),
    # TODO see if needed
    igblast_dir,
    '/makeblastdb -parse_seqids -dbtype nucl -in ',
    out_path,
    '/',
    sample_name,
    '_J_personal_ref.fasta -out ',
    out_path,
    '/J_personal_ref'
  ),
  ignore.stdout = T
)


if (!chain %in% c("IGL", "IGK", "TRA")) {
  param <- c(0.5, 0.5, 0, 0, 0, 0, 0, 0, 0)
  genoD <-
    inferGenotypeBayesian(
      DATA[!grepl(pattern = ',', DATA$d_call) &
             grepl("D", DATA$d_call), ],
      # ignoring multiple assignments and no D assignments.
      find_unmutated = FALSE,
      germline_db = DGERM,
      priors = param,
      v_call = 'd_call',
      seq = "sequence_alignment"
    )
  # get the genotype alleles
  genoD$GENOTYPED_ALLELES <-
    apply(genoD[, c(2, 6:9)], 1, function(y) {
      GENOTYPED_ALLELES(y)
    })

  NOTGENO.IND <-
    !(sapply(strsplit(names(DGERM), '*', fixed = T), '[', 1) %in%  genoD$gene)
  genoD.NEW <- DGERM[NOTGENO.IND]
  for (i in 1:nrow(genoD)) {
    gene <- genoD$gene[i]
    alleles <- genoD$GENOTYPED_ALLELES[i]
    alleles <- unlist(strsplit(alleles, ','))
    IND <- names(DGERM) %in%  paste(gene, alleles, sep = '*')
    genoD.NEW <- c(genoD.NEW, DGERM[IND])
  }

  # writing imgt gapped fasta reference
  write.fasta(
    sequences = as.list(genoD.NEW),
    names = names(genoD.NEW),
    paste0(out_path, '/', sample_name, "_D_personal_ref.fasta"),
    open = "w"
  )

  # create balst db
  system(
    paste0(
      paste0("export IGDATA=", IGDATA, ";"),
      # TODO see if needed
      igblast_dir,
      '/makeblastdb -parse_seqids -dbtype nucl -in ',
      out_path,
      '/',
      sample_name,
      '_D_personal_ref.fasta -out ',
      out_path,
      '/D_personal_ref'
    ),
    ignore.stdout = T
  )

  MAKEDBREPO <- paste(
    paste0(out_path,
           "/",
           sample_name,
           "_V_personal_ref_gapped.fasta"),
    DGERM_PATH,
    JGERM_PATH
    #paste0(out_path, "/", sample_name, "_D_personal_ref.fasta"),
    #paste0(out_path, "/", sample_name, "_J_personal_ref.fasta")
  )

  #germline_db_D <- paste0(out_path, "/", "D_personal_ref")
} else{
  MAKEDBREPO <- paste(
    paste0(out_path,
           "/",
           sample_name,
           "_V_personal_ref_gapped.fasta"),
    " ",
    JGERM_PATH
  )
}
#
# ## run igblast output
# run_igblast(
#   igblast_dir,
#   igdata_path = IGDATA,
#   num_alignments_V,
#   paste0(out_path, "/", "V_personal_ref"),
#   germline_db_D,
#   paste0(out_path, "/", "J_personal_ref"),
#   out_path,
#   paste0(sample_name, "_last_igblast.fasta"),
#   threads,
#   out_path,
#   paste0(sample_name, "_last_db-pass.tsv"),
#   airr = T
# )


## run makedb output
if (dir.exists(file.path(out_path, "tmpf2")))
  system(paste0("rm -r ", file.path(out_path, "tmpf2")))
dir.create(file.path(out_path, "tmpf2"), showWarnings = F)
tmp_dir <- file.path(out_path, "tmpf2")
# get split size

fileSize <-
  as.numeric(system(paste0(
    "grep -c '^>' ",
    paste0(out_path, "/", sample_name, "_last_igblast.fasta")
  ), intern = T))
split = F
if (fileSize > 50000) {
  fileSize <- round(fileSize / vnproc)
  split = T
}
system(
  paste0(
    "SplitSeq.py count -s ",
    paste0(out_path, "/", sample_name, "_last_igblast.fasta"),
    " --outdir ",
    tmp_dir,
    " -n ",
    fileSize
  ),
  ignore.stdout = T
)

tmp_files <- list.files(tmp_dir, "*.fasta$", full.names = T)
report(
  x = "genotype alignment",
  value = 4,
  min = 0,
  max = ifelse(cloned_genotyped, 9, 7)
)

if (split) {
  cluster <- parallel::makeCluster(nproc, type = "FORK")
  # run igblast with makedb
  doParallel::registerDoParallel(cluster)
  invisible(foreach(f = tmp_files, .verbose = F)  %dopar% {
    name <- gsub("[.]fasta", "", basename(f))
    file_ig <- paste0(name, ".out")
    run_igblast(
      igblast_dir,
      igdata_path = NULL,
      num_alignments_V,
      paste0(out_path, "/", "V_personal_ref"),
      germline_db_D,
      germline_db_J,
      #paste0(out_path, "/", "J_personal_ref"),
      fasta_file_path = dirname(f),
      fasta_file = basename(f),
      threads = threads_parallel,
      out_path = tmp_dir,
      out_file = file_ig,
      airr = F
    )

  })

  invisible(foreach(f = tmp_files, .verbose = F) %dopar% {
    name <- gsub("[.]fasta", "", basename(f))
    file_ig <- paste0(name, ".out")
    run_makedb(
      igblast_file = file.path(tmp_dir, file_ig),
      fasta_file = f,
      repo_file = MAKEDBREPO,
      out_path = tmp_dir,
      arg = " --extended"
    )
  })
  stopCluster(cluster)
} else{
  name <- gsub("[.]fasta", "", basename(tmp_files))
  file_ig <- paste0(name, ".out")
  run_igblast(
    igblast_dir,
    igdata_path = NULL,
    num_alignments_V,
    paste0(out_path, "/", "V_personal_ref"),
    germline_db_D,
    germline_db_J,
    #paste0(out_path, "/", "J_personal_ref"),
    fasta_file_path = dirname(tmp_files),
    fasta_file = basename(tmp_files),
    threads = threads,
    out_path = tmp_dir,
    out_file = file_ig,
    airr = F
  )


  run_makedb(
    igblast_file = file.path(tmp_dir, file_ig),
    fasta_file = tmp_files,
    repo_file = MAKEDBREPO,
    out_path = tmp_dir,
    arg = " --extended"
  )


}
tmp_files <- list.files(tmp_dir, "_db-pass.tsv$", full.names = T)

DATA_new <-
  as.data.frame(invisible(data.table::rbindlist(
    lapply(tmp_files, alakazam::readChangeoDb)
  )))
write.table(
  DATA_new,
  paste0(out_path, "/", sample_name, "_last_changeo_db-pass.tsv"),
  sep = '\t',
  row.names = F
)
system(paste0(
  "cat ",
  file.path(out_path, "tmpf2", paste0("*.out")),
  " > ",
  out_path,
  "/",
  sample_name,
  "_last_changeo.out"
))

#if (dir.exists(file.path(out_path, "tmpf2")))
#  system(paste0("rm -rf ", file.path(out_path, "tmpf2")))

# DATA_igblast <-
#   invisible(alakazam::readChangeoDb(paste0(
#     out_path, '/', sample_name, '_last_db-pass.tsv'
#   )))
#
# names_id <-
#   c(NA, unlist(sapply(grep("=", strsplit(DATA_igblast$sequence_id[1], "[|]")[[1]], value =
#                              T), function(x)
#                                strsplit(x, "=")[[1]][1])))
# DATA_igblast <-
#   DATA_igblast %>% tidyr::separate(sequence_id, names_id, sep = "[|]", remove =
#                                      F)
# DATA_igblast <- as.data.frame(DATA_igblast)
# DATA_igblast$sequence_id <-
#   sapply(DATA_igblast$sequence_id, function(x)
#     strsplit(x, "[|]")[[1]][1])
#
# cols_miss <-
#   names(DATA_igblast)[!names(DATA_igblast) %in% names(DATA_changeo)]
# DATA_igblast$sequence_id <- as.character(DATA_igblast$sequence_id)
# DATA_changeo$sequence_id <- as.character(DATA_changeo$sequence_id)
#DATA_new <-
#merge(DATA_changeo, DATA_igblast[, c("sequence_id", cols_miss)], by = "sequence_id") %>% as.data.frame()
#remove(DATA_igblast,DATA_changeo)
DATA_new$c_call <- gsub("c_call=", "", DATA_new$c_call)
names(DATA_new)[which(names(DATA_new) == "c_call")] <- "c_call"

if (length(len_names[grep("_[0-9]", len_names)]) != 0) {
  new_names <- len_names[grep("_[0-9]", len_names)]
  for (n in new_names) {
    ids <- grep(n, DATA_new$v_call, fixed = T)
    DATA_new$v_call[ids] <-
      gsub(n, names(new_names)[new_names == n], DATA_new$v_call[ids], fixed = T)

  }
}

DATA <- DATA[DATA$sequence_id %in% DATA_new$sequence_id, ]
DATA$v_call <-
  sapply(1:nrow(DATA), function(x)
    DATA_new$v_call[DATA_new$sequence_id == DATA$sequence_id[x]])

if (short) {
  cat(paste0(Sys.time(), " - replace names\n"))
  DATA$v_call <-
    stringr::str_replace_all(DATA$v_call,
                             setNames(fr1_names$v_call_new, fr1_names$v_call))
  DATA_new$v_call <-
    stringr::str_replace_all(DATA_new$v_call,
                             setNames(fr1_names$v_call_new, fr1_names$v_call))

  genoV$alleles <- apply(genoV, 1, function(x) {
    stringr::str_replace_all(x[["alleles"]],
                             setNames(fr1_names$ALLELES[fr1_names$GENE ==
                                                          x[["gene"]]],
                                      fr1_names$PATTERN[fr1_names$GENE ==
                                                          x[["gene"]]]))
  })

  genoV$GENOTYPED_ALLELES <- apply(genoV, 1, function(x) {
    stringr::str_replace_all(x[["GENOTYPED_ALLELES"]], setNames(fr1_names$ALLELES[fr1_names$GENE ==
                                                                                    x[["gene"]]], fr1_names$PATTERN[fr1_names$GENE == x[["gene"]]]))
  })

  names(VGERM.NEW) <-
    stringr::str_replace_all(names(VGERM.NEW),
                             setNames(fr1_names$v_call_new, fr1_names$v_call))
}
cat(paste0(Sys.time(), " - read_names\n"))
DATA_new$v_call_genotyped <- DATA_new$v_call
#write.table(DATA_new, paste0(out_path, "/",sample_name,"_test.tsv"), sep='\t', row.names = F)
### get the v_call_original
DATA_tmp <-
  read.table(
    file = collapsed_file,
    sep = "\t",
    header = T,
    stringsAsFactors = F
  )
v_call <- setNames(DATA_tmp$v_call, DATA_tmp$sequence_id)
#  unlist(sapply(DATA_new$sequence_id, function(x)
#    DATA_tmp$v_call[DATA_tmp$sequence_id == x], simplify = F, USE.NAMES = F))
DATA_new$v_call_original <- v_call[DATA_new$sequence_id]

# Filtering seqeunces wihtout D assignment

DATA_new <- DATA_new[grep("J", DATA_new$j_call), ]
DATA_new <-
  DATA_new[!is.na(DATA_new$productive) |
             !is.na(DATA_new$vj_in_frame), ]
DATA_new <- DATA_new[DATA_new$productive & DATA_new$vj_in_frame, ]
DATA_new$subject <- sample_name

# sequence count
cat(paste0(Sys.time(), " - sequence count\n"))
tab_V <- table(grep(",", DATA_new$v_call, invert = T, value = T))
tab_J <- table(grep(",", DATA_new$j_call, invert = T, value = T))

tab_V1 <-
  sapply(names(tab_V), function(x)
    length(grep(
      x, grep(",", DATA$v_call, invert = T, value = T), fixed = T
    )))
tab_J1 <-
  sapply(names(tab_J), function(x)
    length(grep(
      x, grep(",", DATA$j_call, invert = T, value = T), fixed = T
    )))

genoV <-
  genoV %>% dplyr::group_by(gene) %>% dplyr::mutate(
    Freq_by_Clone = paste0(tab_V1[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";"),
    Freq_by_Seq = paste0(tab_V[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";")
  )
genoJ <-
  genoJ %>% dplyr::group_by(gene) %>% dplyr::mutate(
    Freq_by_Clone = paste0(tab_J1[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";"),
    Freq_by_Seq = paste0(tab_J[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";")
  )

if (!chain %in% c("IGL", "IGK", "TRA")) {
  DATA_new <- DATA_new[grep("D", DATA_new$d_call), ]
  tab_D <-
    table(grep(",", DATA_new$d_call, invert = T, value = T))
  tab_D1 <-
    sapply(names(tab_D), function(x)
      length(grep(
        x, grep(",", DATA$d_call, invert = T, value = T), fixed = T
      )))
  genoD <-
    genoD %>% dplyr::group_by(gene) %>% dplyr::mutate(
      Freq_by_Clone = paste0(tab_D1[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";"),
      Freq_by_Seq = paste0(tab_D[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";")
    )
  genos <- plyr::rbind.fill(genoV, genoD, genoJ)
} else{
  genos <- plyr::rbind.fill(genoV, genoJ)
}

genos$Freq_by_Clone <- gsub("NA", "0", genos$Freq_by_Clone)
genos$Freq_by_Seq <- gsub("NA", "0", genos$Freq_by_Seq)
# writting the genotype of the subject in common directory of all the project
write.table(
  genos,
  paste0(out_path, "/", sample_name, "_geno.tsv"),
  sep = '\t',
  row.names = F
)
write.table(
  DATA_new,
  paste0(out_path, "/", sample_name, ".tsv"),
  sep = '\t',
  row.names = F
)


### add binom deletion and haplotype information
## TODO add t cell
report(
  x = "inferring haplotypes",
  value = 4,
  min = 0,
  max = ifelse(cloned_genotyped, 9, 7)
)

# # if (chain %in% c("IGL", "IGK", "IGH")) {
# #   nonReliable_Vgenes = c()
# #   if (short)
# #     nonReliable_Vgenes <- rabhit::nonReliableVGenes(DATA_new)
# #
# #   ### if light get information on both chain.
# #
# #   if (chain == "IGH") {
# #     binom_del <-
# #       rabhit::deletionsByBinom(as.data.frame(DATA_new),
# #                                nonReliable_Vgenes = nonReliable_Vgenes,
# #                                chain = chain)
# #   } else{
# #     chains <- unique(getChain(DATA_new$v_call))
# #
# #     binom_del <-
# #       as.data.frame(data.table::rbindlist(
# #         lapply(chains, function(chain)
# #           rabhit::deletionsByBinom(
# #             as.data.frame(DATA_new %>% filter(grepl(chain, v_call))),
# #             nonReliable_Vgenes = nonReliable_Vgenes,
# #             chain = chain
# #           )),
# #         fill = T
# #       ))
# #   }
# #
# #   genos_names <- names(genos)
# #   for (g in binom_del$gene[grep("^Deletion", binom_del$deletion)]) {
# #     if (g %in% genos$gene) {
# #       genos[genos$gene == g, 2:length(genos_names)] <- NA_real_
# #       genos[genos$gene == g, "k_diff"] <- "1000"
# #       genos[genos$gene == g, "GENOTYPED_ALLELES"] <- "Deletion"
# #
# #     } else{
# #       tmp <- as.data.frame(t(setNames(
# #         c(
# #           g,
# #           rep(NA_character_, 8),
# #           "1000",
# #           "Deletion",
# #           rep(NA_character_, (length(genos_names) - 11))
# #         ), genos_names
# #       )), stringsAsFactors = FALSE)
# #
# #       genos <- plyr::rbind.fill(genos, tmp)
# #     }
# #   }
# #   write.table(
# #     binom_del,
# #     file = paste0(out_path, "/", sample_name, '_binomDel.tsv'),
# #     sep = '\t',
# #     row.names = F,
# #     quote = T
# #   )
# #
# #   haplotype <- c()
# #   haplotypes <- c()
# #
# #   ### check which chain and haplotype genes.
# #
# #   genes_haplotype <- NULL
# #   if (chain == "IGH") {
# #     genes_haplotype <- c('IGHJ6', 'IGHD2-21', 'IGHD2-8')
# #   } else{
# #     if (chain %in% c("IGL", "IGK")) {
# #       genes_haplotype <- c("IGKJ2")
# #     }
# #   }
# #
# #
# #   for (gene in genes_haplotype) {
# #     CALL = paste0(tolower(substr(gene, 4, 4)), "_call")
# #
# #     toHap_GERM = c(VGERM.NEW)
# #     toHap_col = c('v_call')
# #     if (gene == 'IGHJ6') {
# #       CALL = 'j_call'
# #       toHap_GERM = c(VGERM.NEW, DGERM)
# #       toHap_col = c('v_call', 'd_call')
# #     }
# #
# #     tmp <-
# #       grep(gene, grep(',', DATA_new[, CALL], invert = T, value = T), value = T)
# #
# #     if (sum(table(tmp) / length(tmp) >= 0.3) == 2 &&
# #         length(names(table(tmp))) >= 2) {
# #       names_ <- names(table(tmp)[table(tmp) / length(tmp) >= 0.3])
# #       alleles <-
# #         paste0(sapply(names_, function(x)
# #           strsplit(x, '[*]')[[1]][2]), collapse = '_')
# #       chain_haplo = unique(getChain(gene))
# #       haplo <- rabhit::createFullHaplotype(
# #         DATA_new,
# #         toHap_col = toHap_col,
# #         hapBy_col = CALL,
# #         hapBy = gene,
# #         toHap_GERM = toHap_GERM,
# #         deleted_genes = binom_del,
# #         nonReliable_Vgenes = nonReliable_Vgenes,
# #         chain = chain_haplo
# #       )
# #       haplotypes[[gene]] <- haplo
# #       write.table(
# #         haplo,
# #         file = paste0(
# #           out_path,
# #           "/",
# #           sample_name,
# #           '_gene-',
# #           paste0(gene, '-', alleles),
# #           '_haplotype.tsv'
# #         ),
# #         sep = '\t',
# #         row.names = F,
# #         quote = T
# #       )
# #
# #       haplotype <- c(haplotype, paste0(gene, '-', alleles))
# #     }
# #   }
# #
# # }
# write.table(
#   genos,
#   paste0(out_path, "/", sample_name, "_genotype.tsv"),
#   sep = '\t',
#   row.names = F,
#   quote = T
# )

report(
  x = "calculating ogrdb stats",
  value = 5,
  min = 0,
  max = ifelse(cloned_genotyped, 9, 7)
)

##################################################################################
########################## Section Five ##########################################
##################################################################################
## Fifth section includes ogrdbstats


v_calls <-
  unique(sapply(strsplit(unique(DATA_new$v_call), ","), "[", 1))
v_calls <- grep("_[A-Z][0-9]+[A-Z]", v_calls, value = T)
if (file.exists(paste0(out_path, "/", sample_name, "_novel_dataframe.tsv"))) {
  novel_df <-
    read.delim(paste0(out_path, "/", sample_name, "_novel_dataframe.tsv"),
               stringsAsFactors = F)
  if (short) {
    novel_df$polymorphism_call2 <-
      stringr::str_replace_all(novel_df$polymorphism_call,
                               setNames(fr1_names$v_call_new, fr1_names$v_call))
    novel_df <- novel_df[novel_df$polymorphism_call2 %in% v_calls,]
  } else{
    novel_df <- novel_df[novel_df$polymorphism_call %in% v_calls,]
  }
  print(paste0(novel_df$polymorphism_call, collapse = ","))
  novels <-
    setNames(novel_df$novel_imgt, novel_df$polymorphism_call)
} else{
  novels <- c()
}

if (file.exists(paste0(out_path, "/", sample_name, "_novel_gapped.fasta"))) {
  system(paste0(
    "rm -r ",
    paste0(out_path, "/", sample_name, "_novel_gapped.fasta")
  ))
} else{

}

## create repo for stats
if (!chain %in% c("IGL", "IGK")) {
  tigger::writeFasta(c(VGERM, DGERM, JGERM),
                     paste0(out_path, "/", sample_name, "_makedb_ref.fasta"))
} else{
  tigger::writeFasta(c(VGERM, JGERM),
                     paste0(out_path, "/", sample_name, "_makedb_ref.fasta"))
}
MAKEDBREPO <-
  paste0(out_path, "/", sample_name, "_makedb_ref.fasta")

if (short) {
  if (length(novels) != 0) {
    names(VGERM) <-
      stringr::str_replace_all(names(VGERM),
                               setNames(fr1_names$v_call_new, fr1_names$v_call))
    names(novels) <-
      stringr::str_replace_all(names(novels),
                               setNames(fr1_names$v_call_new, fr1_names$v_call))
    for (id in 1:length(novels)) {
      seq = gsub("N", ".", toupper(novels[id]))
      len <- ceiling(nchar(seq) / 3) * 3
      codons <-
        substring(seq, seq(1, len - 2, 3), seq(3, len, 3))
      gaps_lengths <- nchar(gsub("[^\\.\\-]", "", codons))

      id_t <- which(gaps_lengths %in% c(1, 2))
      codons[id_t] <- gsub("[A-Z]", ".", codons[id_t])
      #print(toupper(paste0(codons, collapse = "")))
      novels[id] <- toupper(paste0(codons, collapse = ""))
    }
  }
  ref <- read.fasta(MAKEDBREPO, as.string = T)
  names(ref) <-
    stringr::str_replace_all(names(ref),
                             setNames(fr1_names$v_call_new, fr1_names$v_call))
  for (id in 1:length(ref)) {
    seq = gsub("N", ".", toupper(ref[id]))
    len <- ceiling(nchar(seq) / 3) * 3
    codons <-
      substring(seq, seq(1, len - 2, 3), seq(3, len, 3))
    gaps_lengths <- nchar(gsub("[^\\.\\-]", "", codons))

    id_t <- which(gaps_lengths %in% c(1, 2))
    codons[id_t] <- gsub("[A-Z]", ".", codons[id_t])
    #print(toupper(paste0(codons, collapse = "")))
    ref[id] <- toupper(paste0(codons, collapse = ""))
  }

  write.fasta(
    sequences = as.list(toupper(ref)),
    names = names(ref),
    paste0(out_path, "/", sample_name, "_makedb_ref.fasta"),
    open = "w"
  )
  MAKEDBREPO = paste0(out_path, "/", sample_name, "_makedb_ref.fasta")
} else{
  ref <- read.fasta(MAKEDBREPO, as.string = T)
  #names(ref) <-
  #  stringr::str_replace_all(names(ref),
  #                           setNames(fr1_names$v_call_new, fr1_names$v_call))
  for (id in 1:length(ref)) {
    seq = gsub("N", ".", toupper(ref[id]))
    len <- ceiling(nchar(seq) / 3) * 3
    codons <-
      substring(seq, seq(1, len - 2, 3), seq(3, len, 3))
    gaps_lengths <- nchar(gsub("[^\\.\\-]", "", codons))

    id_t <- which(gaps_lengths %in% c(1, 2))
    codons[id_t] <- gsub("[A-Z]", ".", codons[id_t])
    #print(toupper(paste0(codons, collapse = "")))
    ref[id] <- toupper(paste0(codons, collapse = ""))
  }

  write.fasta(
    sequences = as.list(toupper(ref)),
    names = names(ref),
    paste0(out_path, "/", sample_name, "_makedb_ref.fasta"),
    open = "w"
  )
  MAKEDBREPO = paste0(out_path, "/", sample_name, "_makedb_ref.fasta")

}

if (length(novels) != 0)
  write.fasta(
    sequences = as.list(toupper(novels)),
    names = names(novels),
    paste0(out_path, "/", sample_name, "_novel_gapped.fasta"),
    open = "w"
  )
novel_file <-
  ifelse(
    file.exists(paste0(
      out_path, "/", sample_name, "_novel_gapped.fasta"
    )),
    paste0(out_path, "/", sample_name, "_novel_gapped.fasta"),
    "-"
  )
setwd(out_path)
ogrdbstats::generate_ogrdb_report(
  MAKEDBREPO,
  novel_file,
  "",
  paste0(out_path, "/", sample_name, '.tsv'),
  "IGHV",
  "",
  "V",
  "H",
  F
)
invisible(gc(verbose = FALSE))
invisible(dev.off())


out_files <- c(
  "SAMP_novel_dataframe.tsv",
  "SAMP_geno.tsv",
  "SAMP_ogrdb_plots.pdf",
  "SAMP_ogrdb_report.csv",
  "SAMP.tsv"
)

#### zip intermediate files
out_files <- gsub("SAMP", sample_name,
                  out_files)
out_files <-
  c(out_files, list.files(out_path, paste0(sample_name, "_gene-*")))
all_files <-
  list.files(out_path, "[.][[:alpha:]]+", include.dirs = F)

## check alll files were created
files_stat <- sapply(out_files, function(f) {
  file.exists(file.path(out_path, f))
})
if (!any(files_stat)) {
  cat(paste0(
    "Warning these files weren't created: ",
    names(files_stat)[!files_stat],
    "\n"
  ))
} else{
  cat(paste0("All files were created \n"))
}
all_files <-
  all_files[!all_files %in% names(files_stat)[files_stat]]
dir.create(file.path(out_path, paste0(sample_name, "_interm_files")), showWarnings = F)
system(paste0(
  "mv -u ",
  paste0(file.path(out_path, all_files), collapse = " "),
  " --target-directory=",
  file.path(out_path, paste0(sample_name, "_interm_files"))
))

#
# vref <-
#   read.fasta(paste0(out_path, "/", sample_name, "_V_personal_ref_unchanged.fasta"),
#              as.string = T)
# novels <- vref[grep("_[A-Z][0-9]+[A-Z]", names(vref))]
#
# ## create repo for stats
# if (!chain %in% c("IGL", "IGK", "TRA")) {
#   tigger::writeFasta(c(vref, DGERM, JGERM),
#                      paste0(out_path, "/", sample_name, "_makedb_ref.fasta"))
# } else{
#   tigger::writeFasta(c(vref, JGERM),
#                      paste0(out_path, "/", sample_name, "_makedb_ref.fasta"))
# }
# MAKEDBREPO <-
#   paste0(out_path, "/", sample_name, "_makedb_ref.fasta")
#
# if (short) {
#   if (length(novels) != 0) {
#     names(vref) <-
#       stringr::str_replace_all(names(vref),
#                                setNames(fr1_names$v_call_new, fr1_names$v_call))
#     names(novels) <-
#       stringr::str_replace_all(names(novels),
#                                setNames(fr1_names$v_call_new, fr1_names$v_call))
#     for (id in 1:length(novels)) {
#       seq = gsub("n", ".", novels[id])
#       len <- ceiling(nchar(seq) / 3) * 3
#       codons <- substring(seq, seq(1, len - 2, 3), seq(3, len, 3))
#       gaps_lengths <- nchar(gsub("[^\\.\\-]", "", codons))
#
#       id_t <- which(gaps_lengths %in% c(1, 2))
#       codons[id_t] <- gsub("[a-z]", ".", codons[id_t])
#
#       novels[id] <- toupper(paste0(codons, collapse = ""))
#     }
#   }
#   ref <- read.fasta(MAKEDBREPO, as.string = T)
#   names(ref) <-
#     stringr::str_replace_all(names(ref),
#                              setNames(fr1_names$v_call_new, fr1_names$v_call))
#   for (id in 1:length(ref)) {
#     seq = gsub("n", ".", ref[id])
#     len <- ceiling(nchar(seq) / 3) * 3
#     codons <- substring(seq, seq(1, len - 2, 3), seq(3, len, 3))
#     gaps_lengths <- nchar(gsub("[^\\.\\-]", "", codons))
#
#     id_t <- which(gaps_lengths %in% c(1, 2))
#     codons[id_t] <- gsub("[a-z]", ".", codons[id_t])
#
#     ref[id] <- toupper(paste0(codons, collapse = ""))
#   }
#
#   write.fasta(
#     sequences = as.list(toupper(ref)),
#     names = names(ref),
#     paste0(out_path, "/", sample_name, "_makedb_ref.fasta"),
#     open = "w"
#   )
#   MAKEDBREPO = paste0(out_path, "/", sample_name, "_makedb_ref.fasta")
# }
# if (length(novels) != 0)
#   write.fasta(
#     sequences = as.list(toupper(novels)),
#     names = names(novels),
#     paste0(out_path, "/", sample_name, "_novel_gapped.fasta"),
#     open = "w"
#   )
# novel_file <-
#   ifelse(
#     file.exists(paste0(
#       out_path, "/", sample_name, "_novel_gapped.fasta"
#     )),
#     paste0(out_path, "/", sample_name, "_novel_gapped.fasta"),
#     "-"
#   )
# if (chain == "IGH") {
#   setwd(out_path)
#   ogrdbstats::generate_ogrdb_report(
#     MAKEDBREPO,
#     novel_file,
#     "",
#     paste0(out_path, "/", sample_name, '.tsv'),
#     "IGHV",
#     "IGHJ6",
#     "V",
#     "H",
#     F
#   )
#   invisible(gc(verbose = FALSE))
#   invisible(dev.off())
# } else{
#   if (chain == "IGL") {
#     setwd(out_path)
#     ogrdbstats::generate_ogrdb_report(
#       MAKEDBREPO,
#       novel_file,
#       "",
#       paste0(out_path, "/", sample_name, '.tsv'),
#       "IGKV",
#       "IGKJ2",
#       "V",
#       "L",
#       F
#     )
#     invisible(gc(verbose = FALSE))
#     invisible(dev.off())
#   } else{
#     setwd(out_path)
#     ogrdbstats::generate_ogrdb_report(
#       MAKEDBREPO,
#       novel_file,
#       "",
#       paste0(out_path, "/", sample_name, '.tsv'),
#       "IGLV",
#       "",
#       "V",
#       "L",
#       F
#     )
#     invisible(gc(verbose = FALSE))
#     invisible(dev.off())
#   }
# }
# }else{
#
#     DATA_new <- read.delim(paste0(out_path, "/", sample_name, '.tsv'), stringsAsFactors = F)
#     genos <- read.delim(paste0(out_path, "/", sample_name, "_geno.tsv"), stringsAsFactors = F)
#     genoV <- genos[grep("V",genos$gene),]
#     genoD <- genos[grep("D",genos$gene),]
#     genoJ <- genos[grep("J",genos$gene),]
# }
# ### vdjbase metadata - input is a table output is a yaml file
#
#
# ##################################################################################
# ########################## Section Six ###########################################
# ##################################################################################
# ## Sixth section is optional, inferring clones and adding non functional reads
# out_files <- c(
#   "SAMP_novel_dataframe.tsv",
#   "SAMP_genotype.tsv",
#   "SAMP_ogrdb_plots.pdf",
#   "SAMP_ogrdb_report.csv",
#   "SAMP.tsv"
# )
#
# val_bar = 6
# if (cloned_genotyped) {
#   ## align non functional seuqences
#
#   report(
#     x = "adding filtered nf and conscount sequences",
#     value = val_bar,
#     min = 0,
#     max = ifelse(cloned_genotyped, 9, 7)
#   )
#
#   val_bar <- val_bar + 1
#   db_non <-
#     data.table::fread(
#       file.path(
#         out_path,
#         paste0(sample_name, "_collapsed_non_functional.tsv")
#       ),
#       header = T,
#       stringsAsFactors = F,
#       sep = "\t",
#       data.table = F
#     )
#   db_non <-
#     db_non %>% filter(!productive %in% c("T", TRUE, "True", "TRUE"))
#
#   db_cons <-
#     data.table::fread(
#       file.path(
#         out_path,
#         paste0(
#           sample_name,
#           "_collapsed",
#           "_conscount_below",
#           conscount_filter,
#           ".tsv"
#         )
#       ),
#       header = T,
#       stringsAsFactors = F,
#       sep = "\t",
#       data.table = F
#     )
#
#   db_non <- rbind(db_non, db_cons)
#   remove(db_cons)
#   if (nrow(db_non) != 0) {
#     info_indx = "cdr3"
#     info.strt.idx <- which(names(db_non) == info_indx)
#     unique_information <-
#       names(db_non)[(info.strt.idx + 1):ncol(db_non)]
#     unique_information <-
#       grep("sequence_",
#            unique_information,
#            invert = T,
#            value = T)
#     unique_information <- c("sequence_id", unique_information)
#     seq.names <-
#       sapply(1:nrow(db_non), function(x) {
#         paste0(unique_information,
#                rep('=', length(unique_information)),
#                db_non[x, unique_information],
#                collapse = '|')
#       })
#     seq.names <- gsub('sequence_id=', '', seq.names, fixed = T)
#
#     fasta_file <-
#       file.path(out_path, paste0(sample_name, "_filtered_seqs.fasta"))
#     tigger::writeFasta(setNames(db_non[["sequence"]], seq.names), fasta_file)
#
#     run_igblast(
#       igblast_dir,
#       igdata_path = IGDATA,
#       num_alignments_V,
#       paste0(paste0(out_path, "/", "V_personal_ref")),
#       germline_db_D,
#       paste0(paste0(out_path, "/", "J_personal_ref")),
#       out_path,
#       paste0(sample_name, "_filtered_seqs.fasta"),
#       threads,
#       out_path,
#       paste0(sample_name, "_filtered_seqs.out")
#     )
#
#     run_makedb(
#       file.path(out_path, paste0(sample_name, "_filtered_seqs.out")),
#       file.path(out_path, paste0(sample_name, "_filtered_seqs.fasta")),
#       repo_file = paste(
#         paste0(
#           out_path,
#           "/",
#           sample_name,
#           "_V_personal_ref_gapped.fasta"
#         ),
#         ifelse(
#           chain %in% c("IGH", "TRB"),
#           paste0(out_path, "/", sample_name, "_D_personal_ref.fasta"),
#           " "
#         ),
#         paste0(out_path, "/", sample_name, "_J_personal_ref.fasta")
#       ),
#       out_path = out_path,
#       arg = " --extended"
#     )
#
#     db_non <-
#       invisible(alakazam::readChangeoDb(
#         paste0(out_path, '/', sample_name, '_filtered_seqs_db-pass.tsv')
#       ))
#
#     if (short)
#       db_non$v_call <-
#       stringr::str_replace_all(db_non$v_call,
#                                setNames(fr1_names$v_call_new, fr1_names$v_call))
#
#     db_non <- data.frame(lapply(db_non, function(x)
#       return(as.character(x))), stringsAsFactors = FALSE)
#
#
#     DATA_new <- data.frame(lapply(DATA_new, function(x)
#       return(as.character(x))), stringsAsFactors = FALSE)
#
#     out_file <-
#       file.path(out_path, paste0(sample_name, "_w_filtered_seqs.tsv"))
#     DATA_new <- bind_rows(DATA_new, db_non)
#     readr::write_tsv(DATA_new, out_file, na = "")
#     clone_file <- "_cloned_w_filtered_seqs.tsv"
#     to_clone_file <-
#       file.path(out_path, paste0(sample_name, "_w_filtered_seqs.tsv"))
#   } else{
#     clone_file <- "_cloned.tsv"
#     to_clone_file <-
#       file.path(out_path, paste0(sample_name, ".tsv"))
#   }
#
#
#   ## add non functional sequences and clone
#   report(
#     x = "cloning genotyped data",
#     value = val_bar,
#     min = 0,
#     max = ifelse(cloned_genotyped, 9, 7)
#   )
#   val_bar <- val_bar + 1
#   ## clone sequences
#   system(
#     paste0(
#       'nice -19 CreateGermlines.py ',
#       " -d ",
#       to_clone_file,
#       " --outdir ",
#       out_path,
#       " -g dmask ",
#       " -r ",
#       MAKEDBREPO,
#       " --format airr"
#     ),
#     ignore.stdout = T
#   )
#
#   out_file_clone <-
#     paste0(tools::file_path_sans_ext(to_clone_file),
#            "_germ-pass.tsv")
#
#   system(
#     paste0(
#       'nice -19 DefineClones.py ',
#       " -d ",
#       out_file_clone,
#       " --model hh_s5f",
#       " --dist ",
#       clone_dist,
#       " --mode gene",
#       " --norm len",
#       " --act set",
#       " --sym min",
#       " --outdir ",
#       out_path,
#       " --nproc ",
#       threads,
#       " --failed "
#     ),
#     ignore.stdout = T
#   )
#
#
#   fail <- F
#   if (file.exists(paste0(
#     tools::file_path_sans_ext(out_file_clone),
#     "_clone-fail.tsv"
#   ))) {
#     fail <- T
#     DATA_fail <- data.table::fread(
#       paste0(
#         tools::file_path_sans_ext(out_file_clone),
#         "_clone-fail.tsv"
#       ),
#       header = T,
#       stringsAsFactors = F,
#       sep = "\t",
#       data.table = F
#     )
#   }
#
#   out_file_clone <-
#     paste0(tools::file_path_sans_ext(out_file_clone),
#            "_clone-pass.tsv")
#
#   system(
#     paste0(
#       'nice -19 CreateGermlines.py ',
#       " -d ",
#       out_file_clone,
#       " --outdir ",
#       out_path,
#       " -g dmask --cloned ",
#       " -r ",
#       MAKEDBREPO
#     ),
#     ignore.stdout = T
#   )
#   out_file_clone <-
#     paste0(tools::file_path_sans_ext(out_file_clone),
#            "_germ-pass.tsv")
#
#   DATA_new <- data.table::fread(
#     out_file_clone,
#     header = T,
#     stringsAsFactors = F,
#     sep = "\t",
#     data.table = F
#   )
#
#   tab_V <- table(grep(",", DATA_new$v_call, invert = T, value = T))
#   tab_J <- table(grep(",", DATA_new$j_call, invert = T, value = T))
#
#   tab_V1 <-
#     sapply(names(tab_V), function(x)
#       length(grep(
#         x, grep(",", DATA$v_call, invert = T, value = T), fixed = T
#       )))
#   tab_J1 <-
#     sapply(names(tab_J), function(x)
#       length(grep(
#         x, grep(",", DATA$j_call, invert = T, value = T), fixed = T
#       )))
#
#   genoV <-
#     genoV %>% dplyr::group_by(gene) %>% dplyr::mutate(
#       Freq_by_Clone = paste0(tab_V1[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";"),
#       Freq_by_Seq = paste0(tab_V[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";")
#     )
#   genoJ <-
#     genoJ %>% dplyr::group_by(gene) %>% dplyr::mutate(
#       Freq_by_Clone = paste0(tab_J1[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";"),
#       Freq_by_Seq = paste0(tab_J[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";")
#     )
#
#   if (!chain %in% c("IGL", "IGK", "TRA")) {
#     DATA_new <- DATA_new[grep("D", DATA_new$d_call), ]
#     tab_D <-
#       table(grep(",", DATA_new$d_call, invert = T, value = T))
#     tab_D1 <-
#       sapply(names(tab_D), function(x)
#         length(grep(
#           x, grep(",", DATA$d_call, invert = T, value = T), fixed = T
#         )))
#     genoD <-
#       genoD %>% dplyr::group_by(gene) %>% dplyr::mutate(
#         Freq_by_Clone = paste0(tab_D1[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";"),
#         Freq_by_Seq = paste0(tab_D[paste0(gene, "*", unlist(strsplit(GENOTYPED_ALLELES, ',')))], collapse = ";")
#       )
#     genos <- plyr::rbind.fill(genoV, genoD, genoJ)
#   } else{
#     genos <- plyr::rbind.fill(genoV, genoJ)
#   }
#
#   genos$Freq_by_Clone <- gsub("NA", "0", genos$Freq_by_Clone)
#   genos$Freq_by_Seq <- gsub("NA", "0", genos$Freq_by_Seq)
#   # writting the genotype of the subject in common directory of all the project
#   write.table(
#     genos,
#     paste0(out_path, "/", sample_name, "_geno_cloned.tsv"),
#     sep = '\t',
#     row.names = F
#   )
#
#   if (fail)
#     DATA_new <- bind_rows(DATA_new, DATA_fail)
#   DATA_new$subject <- sample_name
#
#   write.table(
#     DATA_new,
#     file = file.path(out_path, paste0(sample_name, clone_file)),
#     sep = '\t',
#     row.names = F
#   )
#
#   clone_file <- paste0("SAMP", clone_file)
#
#   if (fail)
#     remove(DATA_new, DATA_fail, db_non)
#   remove(DATA_new, db_non)
#   gc(verbose = F)
#
#   out_files <- c(out_files, clone_file)
# }
#
# report(
#   x = "zip intermediate files",
#   value = val_bar,
#   min = 0,
#   max = ifelse(cloned_genotyped, 9, 7)
# )
# val_bar <- val_bar + 1
#
# #### zip intermediate files
# out_files <- gsub("SAMP", sample_name,
#                   out_files)
# out_files <-
#   c(out_files, list.files(out_path, paste0(sample_name, "_gene-*")))
# all_files <-
#   list.files(out_path, "[.][[:alpha:]]+", include.dirs = F)
#
# ## check alll files were created
# files_stat <- sapply(out_files, function(f) {
#   file.exists(file.path(out_path, f))
# })
# if (!any(files_stat)) {
#   cat(paste0(
#     "Warning these files weren't created: ",
#     names(files_stat)[!files_stat],
#     "\n"
#   ))
# } else{
#   cat(paste0("All files were created \n"))
# }
# all_files <-
#   all_files[!all_files %in% names(files_stat)[files_stat]]
# .unlink <- function(x,
#                     recursive = FALSE,
#                     force = FALSE) {
#   if (unlink(x, recursive, force) == 0)
#     return(invisible(TRUE))
#   stop(sprintf("Failed to remove [%s]", x))
# }
# if (rm_files) {
#   .unlink(file.path(out_path, all_files),
#           recursive = T,
#           force = T)
# } else{
#   dir.create(file.path(out_path, paste0(sample_name, "_interm_files")), showWarnings = F)
#
#   system(paste0(
#     "mv -u ",
#     paste0(file.path(out_path, all_files), collapse = " "),
#     " --target-directory=",
#     file.path(out_path, paste0(sample_name, "_interm_files"))
#   ))
#   #if (tar_files) {
#   #  tarfile <-
#   #    file.path(out_path, paste0(sample_name, "_interm_files.tgz"))
#   #  setwd(out_path)
#   #  tar(tarfile,
#   #      paste0(sample_name, "_interm_files"),
#   #      compression = 'gzip')
#   #  .unlink(file.path(out_path, paste0(sample_name, "_interm_files")),
#   #          recursive = T,
#   #          force = T)
#   #}
# }
#
#
# report(
#   x = "",
#   value = val_bar,
#   min = 0,
#   max = ifelse(cloned_genotyped, 9, 7)
# )
