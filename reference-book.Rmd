---
title: "Functional groups"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
biblio-style: apalike
link-citations: yes
---

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

# Functional groups

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = F, error=F, message = F)
#options(repos = BiocManager::repositories())
pacman::p_load('dplyr', 'tidyr', 'htmltools', 'bbplot', 'scales',
               'ggplot2', 'rdrop2', 'shiny', 'BiocManager',
               'dendextend', 'data.table', 'Biostrings', 'alakazam', "unikn", 
               'plotly', "jcolors", 'ggdendro', "RColorBrewer","kmer","heatmaply", install = F)
```

```{r}
source("functions.R")
load("data.rda")
mat <- mat_list$IGH$functional$nonsingle$all$`318`
clust <- hclust(as.dist(mat), "complete")
clusters <- cutree(clust, h = 0.05)
names(clusters) <- names(cutree(clust, h = 0.05))
dend <- as.dendrogram(clust)
fam_clusters <- clusters

clusters <- clusters[order.dendrogram(dend)]
clusters_numbers <- unique(clusters) - (0 %in% clusters)
n_clusters <- length(clusters_numbers)

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

mypal = setNames(alpha(pal %>% usecol(n = n_clusters),0.99), 1:n_clusters) 
cluster_new <- mypal[clusters]

clusters_imgt <- clusters
clusters_imgt <- getGene(names(clusters_imgt), strip_d = F, omit_nl = F)

imgt_colors <-
  setNames(alpha(pal %>% usecol(n = length(unique(clusters_imgt))), 0.99), sort(unique(clusters_imgt)))
clusters_imgt <-   imgt_colors[clusters_imgt]

```

## Sequence pre-processing

Summary statistics for each of the functional groups declared in the app.

The app includes the P1 and P11 naive datasets, and P3, P4, P7, P8, P9 non-naive dataset.

For all projects the following filtration criteria were applied:

* Functional sequence, no stop codons or frame shifts.
* Sequences which start from position 1 of the V gene.
* Sequences which didn't have gaps open (-) and didn't include any N's
* After changing into group annotations, sequences which had more than a single assignment in naive repertoires were remove.

For the non naive datasets only IGM/IGD sequences were taken and the V region was filtered to up to 3 mutations. 

The groups were created with similarity of 95% based on complete linkage and functional sequences and up to position 318.

## Groups Repertoire normalization

The current groups threshold and the possible states are in the table below.

```{r, fig.height=50, fig.width=30, out.height="100%",  out.width="100%"}
chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% rowwise() %>% mutate(gene = getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

groups <- setNames(allele_db$gene_group, allele_db$or_allele)
func$group <- groups[func$allele]

tmp_allele_db <- allele_db %>%
  dplyr::group_by(new_allele) %>% 
  dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <- setNames(tmp_allele_db$or_allele, tmp_allele_db$new_allele)



data_cluster <- data[, v_allele_axis := or_allele[v_call]]
data_cluster$group_plot <- ifelse(is.na(data_cluster$j_call), 1, 2)
data_cluster <- data_cluster[mut == 0 & group_plot == 1]
data_cluster <- data_cluster[, .(v_allele_axis = unlist(tstrsplit(v_allele_axis, "/", type.convert = FALSE))), by = setdiff(names(data_cluster), "v_allele_axis")]
data_cluster2 <- data_cluster %>% filter(v_gene %in% names(absolute_thresholds_dict)) %>% 
  rowwise() %>% 
  dplyr::mutate(thresh = unique(as.numeric(absolute_thresholds_dict[[v_gene]][gsub("IGH","",v_allele_axis)])))
#data_cluster2 <- data_cluster2 %>% filter(freq2>=thresh)

p_list <- list()
i = 1

counts <- c()

for(g_group in names(absolute_thresholds_dict)){
  n_alleles <- func %>% filter(group==g_group) 
  if(nrow(n_alleles)==0) next()
  n_alleles <- n_alleles %>% rowwise() %>% mutate(allele_num = strsplit(allele, "[*]")[[1]][2]) %>% dplyr::arrange(allele_num)
  alleles <- n_alleles$allele
  
  threhsolds <- absolute_thresholds_dict[[g_group]]
  df <- data.frame(v_allele_axis2 = paste0("IGH", names(threhsolds)), thresh = threhsolds, freq2 = 0)
  data_cluster3 <- data_cluster2 %>% filter(v_gene==g_group)
  if(nrow(data_cluster3)==0) next()
  below_thresh <- data_cluster3 %>% filter(freq2<thresh) %>% dplyr::mutate(project = "below thresh",
                                                                           zygousity_state = 0)
  above_thresh <- data_cluster3 %>% filter(freq2>=thresh) %>% dplyr::arrange(desc(freq2)) %>%
    dplyr::group_by(subject) %>% dplyr::mutate(
      zygousity_state = dplyr::n()
    ) %>% arrange(subject)
  
  if(nrow(above_thresh)==0) next()
  
  
  data_cluster4 <- bind_rows(below_thresh, above_thresh)
  data_cluster4$v_allele_axis2 <- factor(data_cluster4$v_allele_axis, n_alleles$allele)
  data_cluster4$v_allele_axis3 <- as.numeric(data_cluster4$v_allele_axis2)
  
  
  dat <- data.frame(group = g_group, allele = "IMGT", v_allele_axis = alleles, alleles = 1, state = "0", novel = F, stringsAsFactors = F)
  
  dat2 <- above_thresh %>% group_by(v_allele_axis) %>% summarise(state = paste0(sort(unique(zygousity_state)), collapse = ","), group = g_group, alleles = 1, allele = "seen") %>% ungroup() %>% dplyr::mutate(novel = grepl("_", v_allele_axis))
  counts <- bind_rows(counts, dat, dat2)
  
  # data_cluster4 <- data_cluster4 %>% dplyr::arrange(desc(freq2)) %>%
  #   dplyr::group_by(subject) %>% dplyr::mutate(
  #     zygousity_state = dplyr::n()
  #   ) %>% arrange(subject)
  # 
  
  p_list[[i]] <- ggplot() + geom_boxplot(data = data_cluster4, mapping = aes(v_allele_axis2, freq2) , outlier.shape = NA) + 
    geom_point(data = data_cluster4, mapping = aes(v_allele_axis2, freq2, color = factor(zygousity_state), shape = project), size = 6, position=position_jitter(width = 0.1)) +
    geom_errorbar(data=df, aes(x = v_allele_axis2, ymin = thresh, ymax = thresh),
                  size=0.5,col="red", linetype = "dashed") +
    labs(x = "", y = "Repertoire\nnormalized", color = "Zygousity", shape = "Project", title = g_group) + 
    theme_bw(base_size = 40) + theme(axis.text.x = element_text(angle = 45, hjust = 1))
  i = i +1
}



```


```{r}
data_thresh <- c()

for(g in names(absolute_thresholds_dict)){
  tmp <- absolute_thresholds_dict[[g]]
  tmp2 <- counts %>% filter(group==g, allele == "seen") %>% select(v_allele_axis, state) %>% dplyr::rename("alleles" = "v_allele_axis")
  tmp3 <-  data.frame(group = g, alleles = paste0("IGH",names(tmp)), thresholds = tmp, stringsAsFactors = F, row.names = NULL)
  tmp4 <- merge(tmp3, tmp2, by = "alleles")
  data_thresh <- bind_rows(data_thresh, tmp4)
}

DT::datatable(data_thresh)

```

Going over the groups showed several thins

1. We saw potential duplication events, such as in the case of IGHV1-69*04 in sample P1_I50 from group G8, where we think this allele might be sitting in the duplicated gene. 
2. An interesting event involving a duplicated gene is in the case of IGHV3-43D from group G22. In this group 5 alleles are present, where three alleles are supposedly from the duplicated gene. Allele D\*04 and D\*04_G4A goes in states two with allele 01, in the J6 heterozygous samples we saw a double single chromosome deletion event. This occurred in 7 individuals and raises the question if maybe both alleles are sitting in the same location on the chromosome and are not acutely deleted.
3. Group 19 and genes IGHV3-23 and IGHV3-23D, showed a very low usage for the D gene. 
4. From the usage results, we suspect that the gene in IGHV3-35G21 might be a pseudo gene.
5. We saw several signle chromosome deletion events in gene V3-66 from the group G25, which also has the gene V3-53.
6. In the group IGHV3-64G27, we suspect that allele 3-64*02 might be a pseudo allele due to very low usage.
7. In group G34 there are only two states, and include two genes. In state one only an allele from V4-30-2 appears. While in state 2, one allele V4-30-2 and one from V4-30-4 appears. 
8. In group G48 there is a novel allele V6-1*01_T91C. This allele only appears in state 2 and is lowly expressed, much more when the max mutation value is 0.


Based on the threshold we compared the alleles present in IMGT versus those that passed the threshold. 

```{r, fig.height=80, fig.width=80}
library(ggh4x)
library(ggpattern)
# p_list_bar <- lapply(unique(counts$group), function(g){
#   ggplot(counts %>% filter(group == g)) + 
#   ggpattern::geom_col_pattern(aes(allele, alleles, fill = state, pattern = novel),
#     colour  = 'white') + theme_bw(18)  #+ 
#   #facet_nested(~ group, scales = "free", nest_line = TRUE)
# 
# })
counts$group <- gsub("IGH","",counts$group)
ggplot(counts) + 
    ggpattern::geom_col_pattern(aes(allele, alleles, fill = state, pattern_density = novel),
                                pattern         = 'circle',
                                colour  = 'black') + theme_bw(100) + labs(y = "count", x = "reference") +
  #ggpattern::pa +
  facet_nested_wrap(.~group, scales = "free", nest_line = TRUE) + theme(legend.position = "top")
```


We plotted the relative repertoire plotted. Each dot is an individual and the colors shows the zygousity state while the shape indicates the project. 

```{r, fig.height=50, fig.width=30}
cowplot::plot_grid(plotlist = p_list[1:5], align = "hv", ncol = 1)
```


```{r, fig.height=50, fig.width=30}
cowplot::plot_grid(plotlist = p_list[6:10], align = "hv", ncol = 1)
```

```{r, fig.height=50, fig.width=30}
cowplot::plot_grid(plotlist = p_list[11:15], align = "hv", ncol = 1)
```

```{r, fig.height=50, fig.width=30}
cowplot::plot_grid(plotlist = p_list[16:20], align = "hv", ncol = 1)
```

```{r, fig.height=50, fig.width=30}
cowplot::plot_grid(plotlist = p_list[21:25], align = "hv", ncol = 1)
```

```{r, fig.height=50, fig.width=30}
cowplot::plot_grid(plotlist = p_list[26:30], align = "hv", ncol = 1)
```

```{r, fig.height=50, fig.width=30}
cowplot::plot_grid(plotlist = p_list[31:35], align = "hv", ncol = 1)
```

```{r, fig.height=50, fig.width=30}
cowplot::plot_grid(plotlist = p_list[36:41], align = "hv", ncol = 1)
```

```{r, fig.height=50, fig.width=30}
cowplot::plot_grid(plotlist = p_list[42:47], align = "hv", ncol = 1)
```


<!--chapter:end:index.Rmd-->

# IGHV1-18 - G1
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% rowwise() %>% mutate(gene = getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV1-18G1'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewed alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.01\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r, eval=knitr::is_html_output(excludes = "epub"), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url("https://functionalgroupsnotes.wordpress.com/ighv1-18g1-notes", height = "1100px")
```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:01-G1.rmd-->

# IGHV1-2 - G2
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV1-2G2'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.01\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```

<!--chapter:end:02-G2.rmd-->

# IGHV1-24 - G3
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV1-24G3'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Observations

For this group we've seen a single allele, hence the general summary statistics do not apply here and were omitted.

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
```

## Conclusions

Because we observed a single allele in this group we set the cutoff to $0.01%$ absolute threshold (the relative repertoire frequency). The plot below shows the frequency of the group above the threshold line.

```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```

<!--chapter:end:03-G3.rmd-->

# IGHV1-3 - G4
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV1-3G4'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.01\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```

<!--chapter:end:04-G4.rmd-->

# IGHV1-45 - G5
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV1-45G5'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```

<!--chapter:end:05-G5.rmd-->

# IGHV1-46 - G6
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV1-46G6'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.01\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```

<!--chapter:end:06-G6.rmd-->

# IGHV1-58 - G7
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV1-58G7'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
```

## Conclusions

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```

<!--chapter:end:07-G7.rmd-->

# IGHV1-69-2 - G8

```{r, echo=FALSE}
source("functions.R")
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV1-69-2G8'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```



No rearrangements were found from this group



<!--chapter:end:08-G8.rmd-->

# IGHV1-69D/IGHV1-69 - G9
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV1-69G9'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

For this group we've seen a single allele, hence the general summary statistics do not apply here and were omitted.

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```

<!--chapter:end:09-G9.rmd-->

# IGHV1-8 - G10
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV1-8G10'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:10-G10.rmd-->

# IGHV2-26 - G11
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV2-26G11'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:11-G11.rmd-->

# IGHV2-5 - G12
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV2-5G12'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:12-G12.rmd-->

# IGHV2-70D/IGHV2-70 - G13
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV2-70G13'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:13-G13.rmd-->

# IGHV3-11 - G14
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-11G14'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:14-G14.rmd-->

# IGHV3-13 - G15
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-13G15'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```

```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:15-G15.rmd-->

# IGHV3-15 - G16
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-15G16'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:16-G16.rmd-->

# IGHV3-20 - G17
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-20G17'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:17-G17.rmd-->

# IGHV3-21 - G18
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-21G18'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:18-G18.rmd-->

# IGHV3-23D/IGHV3-23 - G19
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-23G19'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:19-G19.rmd-->

# IGHV3-30-5/IGHV3-30/IGHV3-33/IGHV3-30-3 - G20
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-30-3G20'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:20-G20.rmd-->

# IGHV3-35 - G21
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-35G21'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Observations

For this group we've seen a single allele, hence the general summary statistics do not apply here and were omitted.

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

<!--chapter:end:21-G21.rmd-->

# IGHV3-43D/IGHV3-43 - G22
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-43G22'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:22-G22.rmd-->

# IGHV3-48 - G23
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-48G23'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:23-G23.rmd-->

# IGHV3-49 - G24
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-49G24'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:24-G24.rmd-->

# IGHV3-66/IGHV3-53 - G25
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-53G25'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:25-G25.rmd-->

# IGHV3-62 - G26
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-62G26'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

No rearrangments were found for this group, hence the general summary statistics do not apply here and were omitted.
## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

<!--chapter:end:26-G26.rmd-->

# IGHV3-64D/IGHV3-64 - G27
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-64G27'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:27-G27.rmd-->

# IGHV3-7 - G28
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-7G28'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:28-G28.rmd-->

# IGHV3-72 - G29
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-72G29'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Observations

For this group we've seen a single allele, hence the general summary statistics do not apply here and were omitted.

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:29-G29.rmd-->

# IGHV3-73 - G30
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-73G30'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:30-G30.rmd-->

# IGHV3-74 - G31
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-74G31'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:31-G31.rmd-->

# IGHV3-9 - G32
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV3-9G32'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:32-G32.rmd-->

# IGHV4-28 - G33
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-28G33'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:33-G33.rmd-->

# IGHV4-30-4/IGHV4-30-2 - G34
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-30-2G34'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:34-G34.rmd-->

# IGHV4-31/IGHV4-30-4 - G35
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-30-4G35'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:35-G35.rmd-->

# IGHV4-34 - G36
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-34G36'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:36-G36.rmd-->

# IGHV4-34 - G37
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-34G37'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

There are no rearrangments for this group.

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r, fig.width=18,fig.height=30}

v_calls <-
    allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
    dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))
v_calls <-  v_calls$new_allele
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```

<!--chapter:end:37-G37.rmd-->

# IGHV4-34 - G37
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-34G37'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

There are no rearrangments for this group.

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r, fig.width=18,fig.height=30}

v_calls <-
    allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
    dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))
v_calls <-  v_calls$new_allele
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```

<!--chapter:end:38-G37.rmd-->

# IGHV4-39/IGHV4-38-2 - G38
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-38-2G38'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:38-G38.rmd-->

# IGHV4-4 - G39
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-4G39'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For this group we have not seen any rearrangements. Hence, no concrete conclusion can be drawn

<!--chapter:end:39-G39.rmd-->

# IGHV4-59/IGHV4-4 - G40
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-4G40'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:40-G40.rmd-->

# IGHV4-59/IGHV4-4 - G41
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-4G41'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:41-G41.rmd-->

# IGHV4-61 - G42
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV4-61G42'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:42-G42.rmd-->

# IGHV5-10-1 - G43
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV5-10-1G43'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:43-G43.rmd-->

# IGHV5-51 - G44
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV5-51G44'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:44-G44.rmd-->

# IGHV6-1 - G45
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV6-1G45'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

## Allele appearnce 

There are no rearrangements for this group. A single allele appear in this group, IGHV4-59G45*06

<!--chapter:end:45-G45.rmd-->

# IGHV7-4-1 - G46
```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% dplyr::rowwise() %>% dplyr::mutate(gene = alakazam::getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = alakazam::getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

edit_links <- readLines("edit_links.txt")
share_links <- readLines("share_links.txt")
```

```{r,echo=FALSE}
g_group = 'IGHV7-4-1G46'
group = names(func_groups)[func_groups==g_group]
gr <- allele_db %>% filter(gene_group == g_group) %>% pull(group) %>% unique()
g <- allele_db %>% filter(gene_group == g_group) %>% pull(gene) %>% unique()
```

## Allele appearnce 

The group of `r group` includes `r length(grep(g_group,allele_db$new_allele,value=T))` alleles, `r sum(func$functionality[func$allele %in% allele_db$or_allele[grep(g_group,allele_db$new_allele)]])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}
allele_appearance(data, g_group, allele_db)
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```
```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align2(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
tagList(sequence_depth(data, g_group, allele_db))
```

## Absolute cutoff

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% dplyr::filter(grepl(as.character(g_group), new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(g_group, "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_g_groups, g_group, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% filter(is.na(j_call)) %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r eval=knitr::is_html_output(excludes = 'epub'), results = 'asis', echo = F}
source_haplo_usage(g_group, allele_thresh)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

You can access the file also from [here](`r edit_links[grep(g_group,edit_links)]`){target="_blank"}

```{r, message=F, echo=F, warning=F}
knitr::include_url(paste0("https://peresay.shinyapps.io/G2_group/?group=",g_group))
# # Authenticate and save token for later use2
# token <- drop_auth(rdstoken = "dropbox_token.rds")
# 
# # Retrieveing your file is as simple as
# drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = FALSE, progress = FALSE)
# drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
# invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = FALSE))
# 
# ui <- fluidPage(
# 
#     # Application title
#     mainPanel(
#       shiny::actionButton(inputId='ab1', label="Edit text", 
#                           icon = icon("edit"), 
#                           onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
#       
#       shiny::actionButton(inputId='ab2', label="Reload text", 
#                           icon = icon("sync-alt")),
#       
#       #htmlOutput("df_output"),
#       uiOutput('markdown')
#     )
# )
# 
# server <- function(input, output) {
#     
#   observeEvent(input$ab2, {
#     drop_download("public/conclusions/IGHV1-2.docx", local_path = "docs/IGHV1-2.docx",
#               overwrite = TRUE, verbose = F)
#     #drop_df <- textreadr::read_docx("docs/IGHV1-2.docx")
#     
#     rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), wd = "docs", verbose = F)
#     output$markdown <- renderUI({
#       #withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
#     
#   })
#     
#   # output$df_output <- renderUI({
#   #       if(input$ab2) return()
#   #       HTML(paste(drop_df, collapse = "<br/><br/>"))
#   #   })
#   
#   output$markdown <- renderUI({
#     #withMathJax(includeMarkdown(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#     HTML(markdown::markdownToHTML(knitr::knit('docs/IGHV1-2_docx.md', quiet = TRUE)))
#   })
# }
# 
# shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we believe that the cutoff for this group should be 
```{r} 
DT::datatable(data.frame(thresholds = absolute_thresholds_dict[[g_group]]))
```

and for the adjusted states the allele combinations and the relations are stated in the table below.

### Allele specific cutoff

```{r}

tableData <- data_cutoff(data, func_groups, g_group, 5, or_allele) %>% dplyr::group_by(zygousity_state, v_allele) %>% dplyr::summarise(mean_freq = paste0(round(quantile(freq2, 3/4),3),":", round(quantile(freq2, 1/4),3)), v_alleles_abc = unique(v_allele_axis)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(mean_freq, collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR range" = "fractions"
        )
      )


# column names change to Zygousity state, alleles combinations, IQR 

```
```{r, out.height= "100%", out.width="100%"}
m <- list(
    l = 50,
    r = 50,
    b = 100,
    t = 100,
    pad = 0.5
)
heatmap_alleles(data, g_group, allele_db, func)%>%
  layout(autosize = F, width = 800, height = 1300)
```


<!--chapter:end:46-G46.rmd-->

